<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>04-树4 是否同一棵二叉搜索树 (25 分)</title>
      <link href="2021/04/08/04-%E6%A0%914-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-25-%E5%88%86/"/>
      <url>2021/04/08/04-%E6%A0%914-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-25-%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在准备考研复习专业课数据结构，所以我在mooc平台上找了浙江大学的数据结构课程重新学习，感觉老师留的课后题都很有趣，所以想记录下自己的学习过程。</p></blockquote><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。最后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p><p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>​    要注意以下，这个题目的输入数据是一次全部输入的，当读取到0的时候才读取完毕。</p><p>​    这个题目的解法就按照题目要求来，既然要判断是否为同一颗搜索二叉树，就先建立搜索二叉树，然后判断是否相等。建立搜索二叉树，是基本操作，然后判断树是否相等就遍历两棵树就行了</p><p>​    具体代码如下</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Tree_node* left;</span><br><span class="line">    Tree_node* right;</span><br><span class="line">&#125;*BST=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Tree_node*  BSTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_BSTree</span><span class="params">(BSTree &amp;BST,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    BSTree pre,temp = BST;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(BST==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        BST = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree_node));</span><br><span class="line">        BST-&gt;data = num;</span><br><span class="line">        BST-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        BST-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//return BST;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            pre = temp;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;(temp-&gt;data))&#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">                flag = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp-&gt;right;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree_node));</span><br><span class="line">        temp-&gt;data = num;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">-1</span>)&#123;</span><br><span class="line">            pre-&gt;left = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;left = temp-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return BST;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsSameTree</span><span class="params">(BSTree a,BSTree b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="literal">NULL</span>&amp;&amp;b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((a==<span class="literal">NULL</span>&amp;&amp;b!=<span class="literal">NULL</span>)||(a!=<span class="literal">NULL</span>&amp;&amp;b==<span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;data==b-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> IsSameTree(a-&gt;left,b-&gt;left)&amp;&amp;IsSameTree(a-&gt;right,b-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l,k,result[<span class="number">1000</span>],count=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(result,<span class="number">-1</span>,<span class="keyword">sizeof</span>(result));</span><br><span class="line">    BSTree first,temp;</span><br><span class="line">    first = temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l);</span><br><span class="line">        first = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            temp = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    insert_BSTree(first,k);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    insert_BSTree(temp,k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                result[count++] = IsSameTree(first,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(result[count]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result[count++]==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(result[count]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result[count++]==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nYes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nNo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> PAT </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree Traversals Again</title>
      <link href="2021/04/04/TreeTraversalsAgain/"/>
      <url>2021/04/04/TreeTraversalsAgain/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在准备考研复习专业课数据结构，所以我在mooc平台上找了浙江大学的数据结构课程重新学习，感觉老师留的课后题都很有趣，所以想记录下自己的学习过程。</p><p>二叉树太难了啊，呜呜呜，太难了家人们。</p></blockquote><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>03-树3 Tree Traversals Again (25 分)</p><p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p><p><img src= "/img/loading.gif" data-lazy-src="https://images.ptausercontent.com/30" alt="img"><br>Figure 1</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>​    题目给出一个出栈入栈序列，可以通过这个序列确定一棵二叉树，要求输出后序遍历的二叉树。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>​    这题有两种思路，第一种是根据入栈出栈序列建立一颗二叉树，然后在对二叉树进行后序遍历。第二种则是根据入栈出栈序列，得到先序遍历和中序遍历的序列，然后在根据这两个序列来推后序遍历序列。</p><p>​    我一开始是想用第一种思路解的，但是太菜了，一直解不出。然后就去查答案，查到了第二种解法的思路。本来想自己根据第二种思路自己写出来，但是还是没写出。唉，我太菜了。最后看了陈越姥姥的样例代码，才做出来的。</p><p>​    对了，看了别人的代码，大家都用c++自带的stl来实现简单的数据结构了，因为我还没学stl，只能傻傻的自己实现这些数据结构。下次得好好学学stl了。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">31</span>];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init_stack</span><span class="params">(SqStack &amp;s)</span></span>&#123;</span><br><span class="line">    s.top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SqStack &amp;s,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">30</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s.data[++s.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(SqStack &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s.data[s.top--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">(SqStack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> front[<span class="number">31</span>]=&#123;<span class="number">0</span>&#125;,mid[<span class="number">31</span>]=&#123;<span class="number">0</span>&#125;,post[<span class="number">31</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> prel,<span class="keyword">int</span> inl,<span class="keyword">int</span> postl,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        post[postl] = front[prel];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    post[postl+n<span class="number">-1</span>] = front[prel];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mid[inl+i]==front[prel])<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L=i, R=n-i<span class="number">-1</span>;</span><br><span class="line">solve(prel+<span class="number">1</span>, inl, postl, L);</span><br><span class="line">solve(prel+<span class="number">1</span>+L, inl+L+<span class="number">1</span>, postl+L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,node;</span><br><span class="line">    Init_stack(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">char</span> act[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> fcount=<span class="number">0</span>,mcount=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,act);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(act,<span class="string">&quot;Push&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;node);</span><br><span class="line">            front[fcount++] = node;</span><br><span class="line">            push(<span class="built_in">stack</span>,node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mid[mcount++] = pop(<span class="built_in">stack</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,post[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,post[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 非递归遍历二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List Leaves</title>
      <link href="2021/04/04/ListLeaves/"/>
      <url>2021/04/04/ListLeaves/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在准备考研复习专业课数据结构，所以我在mooc平台上找了浙江大学的数据结构课程重新学习，感觉老师留的课后题都很有趣，所以想记录下自己的学习过程。</p></blockquote><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to <em>N</em>−1. Then <em>N</em> lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 -</span><br><span class="line">- -</span><br><span class="line">0 -</span><br><span class="line">2 7</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">5 -</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 5</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>​    题目的意思是要求按照从上到下，从左到右的顺序依次输出二叉树的叶子结点。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>​    这题没什么好说的，直接用一个辅助队列进行层次遍历就可以得到结果。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> empty -1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Btree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">11</span>];</span><br><span class="line">&#125;h_queue;<span class="comment">//为了实现层序遍历的辅助队列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init_queue</span><span class="params">(Queue &amp;q)</span></span>&#123;<span class="comment">//初始化队列</span></span><br><span class="line">    q.front = <span class="number">0</span>;</span><br><span class="line">    q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Is_empty</span><span class="params">(Queue &amp;q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.rear==q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Add_item</span><span class="params">(Queue &amp;q,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">if</span>((q.rear+<span class="number">1</span>)%<span class="number">11</span>==q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q.rear = (q.rear+<span class="number">1</span>)%<span class="number">11</span>;</span><br><span class="line">    q.data[q.rear] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Delete_item</span><span class="params">(Queue &amp;q)</span></span>&#123;<span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">if</span>(q.rear==q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q.front = (q.front+<span class="number">1</span>)%<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">return</span> q.data[q.front];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_leaves</span><span class="params">(Btree *q,Queue &amp;h_queue,<span class="keyword">int</span> head,<span class="keyword">int</span> result[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    Add_item(h_queue,head);</span><br><span class="line">    <span class="keyword">while</span>(Is_empty(h_queue))&#123;</span><br><span class="line">        i = Delete_item(h_queue);</span><br><span class="line">        <span class="keyword">if</span>(q[i].left==empty&amp;&amp;q[i].right==empty)</span><br><span class="line">            result[count++] = q[i].data;</span><br><span class="line">        <span class="keyword">if</span>(q[i].left!=empty)</span><br><span class="line">            Add_item(h_queue,q[i].left);</span><br><span class="line">        <span class="keyword">if</span>(q[i].right!=empty)</span><br><span class="line">            Add_item(h_queue,q[i].right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>,judge[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;,head=<span class="number">0</span>,result[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">memset</span>(result,<span class="number">-1</span>,<span class="keyword">sizeof</span>(result));</span><br><span class="line">    <span class="keyword">char</span> save[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    Btree tree[<span class="number">11</span>];</span><br><span class="line">    <span class="comment">//读取二叉树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n%c %c&quot;</span>,&amp;save[<span class="number">0</span>],&amp;save[<span class="number">1</span>]);</span><br><span class="line">        tree[i].data = i;</span><br><span class="line">        <span class="keyword">if</span>(save[<span class="number">0</span>]!=<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            tree[i].left = save[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            judge[tree[i].left] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree[i].left = empty;</span><br><span class="line">        <span class="keyword">if</span>(save[<span class="number">1</span>]!=<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            tree[i].right = save[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            judge[tree[i].right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree[i].right = empty;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找头节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!judge[i])</span><br><span class="line">            head = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取叶结点保存到result数组中</span></span><br><span class="line">    <span class="keyword">if</span>(head!=empty)&#123;</span><br><span class="line">        Init_queue(h_queue);</span><br><span class="line">        read_leaves(tree,h_queue,head,result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印结果</span></span><br><span class="line">    <span class="keyword">if</span>(result[<span class="number">0</span>]!=<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(result[i]!=<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,result[i++]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的同构</title>
      <link href="2021/03/31/%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/"/>
      <url>2021/03/31/%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在准备考研复习专业课数据结构，所以我在mooc平台上找了浙江大学的数据结构课程重新学习，感觉老师留的课后题都很有趣，所以想记录下自己的学习过程。</p></blockquote><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://images.ptausercontent.com/28" alt="img"></p><p>图1</p><p><img src= "/img/loading.gif" data-lazy-src="https://images.ptausercontent.com/29" alt="img"></p><p>图2</p><p>现给定两棵树，请你判断它们是否是同构的。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数<em>N</em> (≤10)，即该树的结点数（此时假设结点从0到<em>N</em>−1编号）；随后<em>N</em>行，第<em>i</em>行对应编号第<em>i</em>个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><h3 id="输入样例1（对应图1）："><a href="#输入样例1（对应图1）：" class="headerlink" title="输入样例1（对应图1）："></a>输入样例1（对应图1）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例2（对应图2）："><a href="#输入样例2（对应图2）：" class="headerlink" title="输入样例2（对应图2）："></a>输入样例2（对应图2）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">B 5 7</span><br><span class="line">F - -</span><br><span class="line">A 0 3</span><br><span class="line">C 6 -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G 4 -</span><br><span class="line">E 1 -</span><br><span class="line">8</span><br><span class="line">D 6 -</span><br><span class="line">B 5 -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C 0 2</span><br><span class="line">G - 3</span><br><span class="line">F - -</span><br><span class="line">A 1 4</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>​    对于二叉树我是真的不会，我还是看了何钦铭老师的小白专场讲解才做出来的。这一题有很多细节，但是主要操作只有两个，第一个是建立二叉树；第二个是判断两颗树是否同构。</p><p>​    因为题目给出的结点都是以编号的方式给出的，所以我们可以用结构数组来储存二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;Tree;</span><br></pre></td></tr></table></figure><p>​    读取数据的时候有些结点的孩子坐标为‘-’，所以我们用char类型来读取，判断是‘-’，就转换成数字49（不要问我为什么用49而不用-1，因为‘-’的ASCII码值为49，我一开始想直接用int读取‘-’，代码都是用49来判断结点是否为空，结果出错了），不是‘-’，就转换为本来的数字。</p><p>​    难点是怎么判断两棵树是否同构，我一开始知道要用递归的写法来判断，但是我的思路错了。我一开始想的是先判断A树B树的头节点，然后判断他们的左右孩子是否相等。如果不相等，就交换一次在判断相不相等；若交换后相等则继续判断他们的左右孩子的左右孩子是否相等，若交换后不相等则退出。但是这种想法很难实现会漏掉很多情况。</p><p>​    后面就看了老师的思路，用了老师的方法。</p><p>具体代码如下</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;Tree;</span><br><span class="line"><span class="keyword">int</span> isomorphism;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_isomorphism</span><span class="params">(Tree* A,<span class="keyword">int</span> t1,Tree* B,<span class="keyword">int</span> t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1==<span class="number">49</span>&amp;&amp;t2==<span class="number">49</span>)&#123;<span class="comment">//若两棵树都为空，则同构</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t1==<span class="number">49</span>&amp;&amp;t2!=<span class="number">49</span>||t1!=<span class="number">49</span>&amp;&amp;t2==<span class="number">49</span>)&#123;<span class="comment">//两棵树其中一颗为空树而另一棵树不空则不同构</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A[t1].data!=B[t2].data)&#123;<span class="comment">//两棵树都不为空，若头节点不相同则不同构</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A[t1].left==<span class="number">49</span>&amp;&amp;B[t2].left==<span class="number">49</span>)&#123;<span class="comment">//两棵树都不为空，且两树的左子树都为空，则判断右子树是否同构</span></span><br><span class="line">        <span class="keyword">return</span> is_isomorphism(A,A[t1].right,B,B[t2].right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((A[t1].left!=<span class="number">49</span>&amp;&amp;B[t2].left!=<span class="number">49</span>)&amp;&amp;(A[A[t1].left].data==B[B[t2].left].data))&#123;</span><br><span class="line">        <span class="comment">//两棵树都不为空，且两树的左子树都不为空，左子树头节点还相等，则递归的判断两棵树的左右子树是否同构</span></span><br><span class="line">        <span class="keyword">return</span> (is_isomorphism(A,A[t1].left,B,B[t2].left)&amp;&amp;is_isomorphism(A,A[t1].right,B,B[t2].right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//剩余情况则要交换左右子树，并判断是否同构</span></span><br><span class="line">        <span class="keyword">return</span> (is_isomorphism(A,A[t1].left,B,B[t2].right)&amp;&amp;is_isomorphism(A,A[t1].right,B,B[t2].left));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1,n2,left,right,first_head=<span class="number">49</span>,second_head=<span class="number">49</span>;</span><br><span class="line">    <span class="keyword">char</span> data=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> save[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//读取第一棵树</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n1);</span><br><span class="line">    Tree first_tree[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> first[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n1!=<span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n%c %c %c&quot;</span>,&amp;first_tree[i].data,&amp;save[<span class="number">0</span>],&amp;save[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(save[<span class="number">0</span>]==data)</span><br><span class="line">            first_tree[i].left = <span class="number">49</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            first_tree[i].left = save[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(save[<span class="number">1</span>]==data)</span><br><span class="line">            first_tree[i].right = <span class="number">49</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            first_tree[i].right = save[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(first_tree[i].left!=<span class="number">49</span>)</span><br><span class="line">            first[first_tree[i].left] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(first_tree[i].right!=<span class="number">49</span>)</span><br><span class="line">            first[first_tree[i].right] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取第二棵树</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n2);</span><br><span class="line">    Tree second_tree[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> second[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n2!=<span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n2;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n%c %c %c&quot;</span>,&amp;second_tree[i].data,&amp;save[<span class="number">0</span>],&amp;save[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(save[<span class="number">0</span>]==data)</span><br><span class="line">            second_tree[i].left = <span class="number">49</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            second_tree[i].left = save[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(save[<span class="number">1</span>]==data)</span><br><span class="line">            second_tree[i].right = <span class="number">49</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            second_tree[i].right = save[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(second_tree[i].left!=<span class="number">49</span>)</span><br><span class="line">            second[second_tree[i].left] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(second_tree[i].right!=<span class="number">49</span>)</span><br><span class="line">            second[second_tree[i].right] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//找第一颗树的头节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!first[i])</span><br><span class="line">            first_head = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找第二颗树的头节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!second[i])</span><br><span class="line">            second_head = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始判断两棵树是否同构</span></span><br><span class="line">    isomorphism = is_isomorphism(first_tree,first_head,second_tree,second_head);</span><br><span class="line">    <span class="keyword">if</span>(isomorphism||(n1==<span class="number">0</span>&amp;&amp;n2==<span class="number">0</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PAT </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合法的出栈序列</title>
      <link href="2021/03/29/%E5%90%88%E6%B3%95%E7%9A%84%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97/"/>
      <url>2021/03/29/%E5%90%88%E6%B3%95%E7%9A%84%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在准备考研复习专业课数据结构，所以我在mooc平台上找了浙江大学的数据结构课程重新学习，感觉老师留的课后题都很有趣，所以想记录下自己的学习过程。</p></blockquote><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p><strong>按照惯例先秀一下AC的图</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@a0bdc0fa5f5fdaee8373bc632fbfd4b0287c54d6/2021/03/29/6df28ef53d2fb946f1374d1b66138050.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>​    限定堆栈的最大容量M，然后给出一个从1到N的序列按顺序依次入栈；我们可以随机的选择出栈的时刻。要求判断给出的K个出栈序列是否合法。（M,N,K都不超过1000）</p><p>​    假如M=5,N=7，那么 1, 2, 3, 4, 5, 6, 7 这个出栈序列是合法的，而3, 2, 1, 7, 5, 6, 4 这个出栈序列则是非法的。因为当7出栈后，栈顶元素应该为6，但是此序列给出的下一个出栈元素为5，故此序列不合法。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>​    我的思路是这样的，首先我将每一个出栈序列都按顺序保存下来，然后建立一个空堆栈，首先将堆栈里push一个0进去。于是我就可以拿栈顶的元素和保存下来的出栈序列作比较，从序列的第一个元素一直比较到第K个元素，每次比较有三种情况</p><p>①如果栈顶元素&lt;出栈序列中的第i个元素，那么就将push（栈顶元素+2），若push失败，说明超出堆栈的范围，直接break，此序列不合法。</p><p>②栈顶元素=出栈序列中的第i个元素，那么就把栈顶元素pop出来，并且i=i+1</p><p>③栈顶元素&gt;出栈序列中的第i个元素，说明序列不合法，直接break退出循环。</p><p>循环从1执行到N，循环结束，若没有①②这两种情况则说明，此出栈序列为合法的出栈序列。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SqStack &amp;<span class="built_in">stack</span>,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>.top==<span class="built_in">stack</span>.size <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.data[++(<span class="built_in">stack</span>.top)] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(SqStack &amp;<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.data[(<span class="built_in">stack</span>.top)--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k,j,count,<span class="built_in">list</span>[k+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> result[k+<span class="number">1</span>],temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">    SqStack <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>.size = m+<span class="number">1</span>;<span class="comment">//因为一开始要push 0 进去所以多增加一个空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化结果数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        result[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//读取出栈序列，保存在list中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">list</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">stack</span>.top = <span class="number">-1</span>;</span><br><span class="line">        push(<span class="built_in">stack</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//判断该序列是否合法</span></span><br><span class="line">        j=<span class="number">1</span>;count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>.data[<span class="built_in">stack</span>.top]&lt;<span class="built_in">list</span>[i][count])&#123;</span><br><span class="line">                temp = push(<span class="built_in">stack</span>,j);</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(!temp)&#123;<span class="comment">//堆栈已满，插入失败</span></span><br><span class="line">                    result[i] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>.data[<span class="built_in">stack</span>.top]==<span class="built_in">list</span>[i][count])&#123;</span><br><span class="line">                pop(<span class="built_in">stack</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>.data[<span class="built_in">stack</span>.top]&gt;<span class="built_in">list</span>[i][count])&#123;</span><br><span class="line">                result[i] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result[k]) <span class="built_in">printf</span>(<span class="string">&quot;YES&quot;</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> PAT </tag>
            
            <tag> 堆栈 </tag>
            
            <tag> 线性结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表反转</title>
      <link href="2021/03/28/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
      <url>2021/03/28/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在准备考研复习专业课数据结构，所以我在mooc平台上找了浙江大学的数据结构课程重新学习，感觉老师留的课后题都很有趣，所以想记录下自己的学习过程。</p></blockquote><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><p><strong>先秀一下AC的图，嘿嘿</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@215503bd575b1566a89d75dc3f95be3dda9b4e5f/2021/03/28/448c021464aea79c20c51001f04a9e63.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>​    这道题目的大概意思是要求将一个长度为N的链表每k个元素的位置反转过来。</p><p>例如 链表为 1→2→3→4→5→6 当k为3时，反转后的链表就应该为3→2→1→6→5→4；当k为4时，反转后的链表就应该为4→3→2→1→5→6。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>不过离谱的是，这题目又不直接给个链表，而是给结点的地址、值和下一个结点的地址（难道出题老师是为了考虑其他不用c或者c++的同学？），所以要解这个题，我们要先建立链表（有的同学想把数据直接全存数组中，然后排好序之后输出；可是老师也想到了这种投机取巧的方法，于是测试数据中增加了不在链表上的结点）。</p><p>建立链表之前肯定得把之前的结点都存起来，然后才能建立链表。所以很自然的就想出要有两个结构体，一个是保存结点的数据，另一个自然是链表了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;Node;</span><br><span class="line">Node List[<span class="number">100000</span>];<span class="comment">//因为给的地址是5位数的，所以我们要创建一个100000大小的数组来存储它</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    point *next;</span><br><span class="line">&#125;point,*Link;</span><br></pre></td></tr></table></figure><p>有了结构体，我们自然要读取结点然后创建链表了，这都是常规操作故不详细说明。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k,n,head,address;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;head,&amp;n,&amp;k);</span><br><span class="line"></span><br><span class="line">Link q,true_list,r;</span><br><span class="line">q = true_list = (Link)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(point));</span><br><span class="line">q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先将数据读入结构体中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;address);</span><br><span class="line">    List[address].address = address;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;(List[address].data),&amp;(List[address].next));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立真正的链表</span></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">address = head;</span><br><span class="line"><span class="keyword">while</span>(address!=<span class="number">-1</span>)&#123;</span><br><span class="line">    r = (Link)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(point));</span><br><span class="line">    r-&gt;address = address;</span><br><span class="line">    r-&gt;data = List[address].data;</span><br><span class="line">    address = List[address].next;</span><br><span class="line">    q-&gt;next = r;</span><br><span class="line">    q = r;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/***********************************************************************/</span></span><br></pre></td></tr></table></figure><p>建立好链表之后就终于到了重头戏了。</p><p>因为是反转，所以我想到用前插法，就是把后来的结点插到之前结点的前面，每k个结点一个循环。总共有链表结点总数除以k个循环，然后剩下的链表元素直接插到后面就行了。</p><p>比如 1→2→3→4→5→6 当k为3时</p><p>6/3 = 2，所以要做两个循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一次循环</span><br><span class="line">第一次 1</span><br><span class="line">第二次 2→1</span><br><span class="line">第三次 3→2→1</span><br><span class="line">结点指针要重指回 1结点</span><br><span class="line">第二次循环</span><br><span class="line">第一次 3→2→1→4</span><br><span class="line">第二次 3→2→1→5→4</span><br><span class="line">第三次 3→2→1→6→5→4</span><br><span class="line">就得到了所要求的结果</span><br></pre></td></tr></table></figure><p>逆转代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始逆转</span></span><br><span class="line">   <span class="keyword">int</span> reverse_num = count/k;</span><br><span class="line">   Link result,temp,s;</span><br><span class="line">   s = result = temp =(Link)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(point));</span><br><span class="line">   true_list = true_list-&gt;next;</span><br><span class="line">   temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;reverse_num;i++)&#123;</span><br><span class="line">           s = true_list;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">           r=true_list;</span><br><span class="line">           true_list = r-&gt;next;</span><br><span class="line">           r-&gt;next = temp-&gt;next;</span><br><span class="line">           temp-&gt;next = r;</span><br><span class="line">           <span class="keyword">if</span>(j==k<span class="number">-1</span>)</span><br><span class="line">               temp = s;</span><br><span class="line">       &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将剩余结点接上</span></span><br><span class="line">   temp = s;</span><br><span class="line">   temp-&gt;next = true_list;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;Node;</span><br><span class="line">Node List[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    point *next;</span><br><span class="line">&#125;point,*Link;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,n,head,address;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;head,&amp;n,&amp;k);</span><br><span class="line">    </span><br><span class="line">    Link q,true_list,r;</span><br><span class="line">    q = true_list = (Link)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(point));</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先将数据读入结构体中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;address);</span><br><span class="line">        List[address].address = address;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;(List[address].data),&amp;(List[address].next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立真正的链表</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">    address = head;</span><br><span class="line">    <span class="keyword">while</span>(address!=<span class="number">-1</span>)&#123;</span><br><span class="line">        r = (Link)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(point));</span><br><span class="line">        r-&gt;address = address;</span><br><span class="line">        r-&gt;data = List[address].data;</span><br><span class="line">        address = List[address].next;</span><br><span class="line">        q-&gt;next = r;</span><br><span class="line">        q = r;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/***********************************************************************/</span></span><br><span class="line">    <span class="comment">//开始逆转</span></span><br><span class="line">    <span class="keyword">int</span> reverse_num = count/k;</span><br><span class="line">    Link result,temp,s;</span><br><span class="line">    s = result = temp =(Link)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(point));</span><br><span class="line">    true_list = true_list-&gt;next;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;reverse_num;i++)&#123;</span><br><span class="line">            s = true_list;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            r=true_list;</span><br><span class="line">            true_list = r-&gt;next;</span><br><span class="line">            r-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = r;</span><br><span class="line">            <span class="keyword">if</span>(j==k<span class="number">-1</span>)</span><br><span class="line">                temp = s;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余结点接上</span></span><br><span class="line">    temp = s;</span><br><span class="line">    temp-&gt;next = true_list;</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    result = result-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(result)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,result-&gt;address,result-&gt;data,result-&gt;next-&gt;address);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>,result-&gt;address,result-&gt;data);</span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> PAT </tag>
            
            <tag> 线性结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库 关系数据库</title>
      <link href="2021/01/08/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2021/01/08/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h1><h2 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li><p>1、域</p><ul><li>域是一组具有相同数据类型的值的集合</li></ul></li><li><p>2.笛卡尔积</p><ul><li></li></ul></li><li><p>3.关系</p><ul><li>若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系有多个候选码，则选定其中一个为主码。候选码的诸属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。</li><li>关系可以有三种类型：基本关系（通常又称为基本表或基表）、查询表和视图表。其中，基本表是实际存在的表，它是实际存储数据的逻辑表示；查询表是查询结果对应的表；视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的储数据。</li><li>关系的每一个分量必须是一个不可分的数据项</li></ul></li></ul><h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><ul><li>关系的描述称为关系模式。它可以形式化地标识为R（U,D,DOM,F）其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性想域的映像集合，F为属性见数据的依赖关系集合。</li></ul><h3 id="关系数据库-1"><a href="#关系数据库-1" class="headerlink" title="关系数据库"></a>关系数据库</h3><ul><li>在一个给定的应用领域中，所有关系的集合构成一个关系数据库。</li><li>关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库模式包括若干域的定义，以及在这些域上定义的若干关系模式。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</li></ul><h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><h3 id="基本的关系操作"><a href="#基本的关系操作" class="headerlink" title="基本的关系操作"></a>基本的关系操作</h3><ul><li>关系模型中常用的关系操作包括查询（query）操作和插入（insert）、删除（delete）、修改（updata）操作两大部分。</li><li>关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为选择（select）、投影（project）、连接（join）、除（divide）、并（union）、差（except）、交（intersection）、笛卡尔积等。其中选择、投影、并、差、笛卡尔积是5种基本操作。</li></ul><h3 id="关系数据语言的分类"><a href="#关系数据语言的分类" class="headerlink" title="关系数据语言的分类"></a>关系数据语言的分类</h3><ul><li><p>关系代数语言（例如ISBL）</p></li><li><p>关系演算语言</p><ul><li>元组关系盐酸语言（例如ALPHA、QUEL）</li><li>域关系演算语言（例如QBE）</li></ul></li><li><p>具有关系代数和关系演算双重特点的语言（例如SQL）</p></li></ul><h2 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h2><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><ul><li>若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取控制。所谓控制就是“不知道”或“不存在”或“无意义”的值。</li></ul><h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul><li><p>设F是基本关系R的一个或一组属性，但不是关系R的码，K是基本关系S的住吗。如果F与K相对于，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系</p></li><li><p>若属性（属性组）F是基本关系R的外码，它与基本关系S的主码K相对应（基本关系R和S不一定是不同的关系），则对于R种每个元组在F上的值必须：</p><ul><li>或者取空值</li><li>或者等于S种每个元组的主码值</li></ul></li></ul><h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><ul><li>用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用设计的数据必须满足的语义要求。</li></ul><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h3><h3 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库 绪论</title>
      <link href="2021/01/08/%E7%BB%AA%E8%AE%BA/"/>
      <url>2021/01/08/%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><h3 id="数据库的4个基本概念"><a href="#数据库的4个基本概念" class="headerlink" title="数据库的4个基本概念"></a>数据库的4个基本概念</h3><ul><li><p>1.数据</p><ul><li>数据时数据库中存储的基本对象。描述事物的符号记录称为数据。</li></ul></li><li><p>2.数据库</p><ul><li>数据库时长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度（redundancy）、较高的数据独立性（data independencey）和易扩展性（scalability），并可为各种用户共享。概括地讲，数据库数据具有用久存储、有组织和可共享三个基本特点。</li></ul></li><li><p>3.数据库管理系统</p><ul><li><p>数据库管理系统是位于用户与操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是计算机的基础软件，也是一个大型复杂的软件系统。它的主要功能包括以下几个方面：</p><ul><li><p>（1）数据定义功能</p><ul><li>数据库管理系统提供数据定义语言（Data Definition Language， DDL），用户通过它可以方便地对数据库中的数据对象的组成与结构进行定义。</li></ul></li><li><p>（2）数据组织、存储和管理</p><ul><li>数据库管理系统要分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。要确定以何种文件结构和存取方式在存储级上组织这些数据，如何实现数据之间的联系。数据组织和存储的基本目标是提高存储空间利用率和方便存取，提供多种存取方式（如索引查找、hash查找、顺序查找等）来提高存取效率。</li></ul></li><li><p>（3）数据操控功能</p><ul><li>数据库管理系统还提供数据操纵语言（Data Manipulation Language，DML），用户可以使用它操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。</li></ul></li><li><p>（4）数据库的事务管理和运行管理</p><ul><li>数据库在建立、运用和维护时由数据库管理系统统一管理和控制，以保证事务的正确运行，保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。</li></ul></li><li><p>（5）数据库的建立和维护功能</p><ul><li>数据库的建立和维护功能包括数据库舒适数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。这些功能通常是由一些使用程序或管理工具完成的。</li></ul></li><li><p>（6）其他功能</p><ul><li>其他功能包括数据库管理系统与网络中其他软件系统的通信功能，一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能，异构数据库之间的互访和互操作功能等</li></ul></li></ul></li></ul></li><li><p>4.数据库系统</p><ul><li>数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator，DBA）组成的存储、管理、处理和维护数据的系统。</li></ul></li></ul><h3 id="数据管理技术的产生和发展"><a href="#数据管理技术的产生和发展" class="headerlink" title="数据管理技术的产生和发展"></a>数据管理技术的产生和发展</h3><ul><li><p>1.人工管理阶段</p><ul><li>（1）数据不保存</li><li>（2）应用程序管理数据</li><li>（3）数据不共享</li><li>（4）数据不具有独立性</li></ul></li><li><p>2.文件系统阶段</p><ul><li>（1）数据可以长期保存</li><li>（2）由文件系统管理数据</li><li>（3）数据共享性差，冗余度大</li><li>（4）数据独立性差</li></ul></li><li><p>3.数据库系统阶段</p></li></ul><h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><ul><li><p>1.数据结构化</p><ul><li>数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。</li></ul></li><li><p>2.数据的共享性高、冗余度低且易扩充</p><ul><li>数据共享可以大大减少书记荣誉，节约存储空间，数据共享还能够避免数据之间的不相容性与不一致性。</li></ul></li><li><p>3.数据独立性高</p><ul><li>数据独立性是借助数据库管理数据的一个显著优点，它已称为数据库领域中一个常用术语和重要概念，包括数据的物理独立性和逻辑独立性。</li><li>物理独立性是指用户的应用程序与数据库中数据的物理存储时相互独立的。</li><li>逻辑独立性是指用户的应用程序与数据库的逻辑结构时相互独立的。</li></ul></li><li><p>4.数据由数据库管理系统统一管理和控制</p><ul><li>（1）数据的安全性（securi）保护</li><li>（2）数据的完整性（integrity）检查</li><li>（3）并发（concurrency）控制</li><li>（4）数据库恢复（recovery）</li></ul></li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h3><ul><li><p>第一类：概念模型</p><ul><li>概念模型也称信息模型，它是按用户的观点来来对数据和信息建模，主要用于数据库设计。</li></ul></li><li><p>第二类：逻辑模型和物理模型</p><ul><li>第二类中的逻辑模型主要包括层次模型、网状模型、关系模型、面向对象数据模型和对象关系数据模型、半结构化数据模型等。它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。</li><li>第二类中的物理模型是对数据最底层的抽象，它面熟数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方式，是面向计算机系统的。物理模型的具体实现是数据库管理系统的任务，数据库设计人员要了解和选择物理模型，最终用户则不必考虑物理级的细节。</li></ul></li></ul><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><ul><li><p>1.信息世界中的基本概念</p><ul><li><p>（1）实体（entity）</p><ul><li>客观存在并可相互区别的事物称为实体。</li></ul></li><li><p>（2）属性（attribute）</p><ul><li>实体所具有的某一特性称为属性。</li></ul></li><li><p>（3）码（key）</p><ul><li>唯一标识实体的属性集称为码。</li></ul></li><li><p>（4）实体型（entity type）</p><ul><li>具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li></ul></li><li><p>（5）实体集（entity set）</p><ul><li>同一类型的集合称为实体集。</li></ul></li><li><p>（6）联系（relationship）</p><ul><li>一对一、一对多、多对多等多种类型</li></ul></li></ul></li><li><p>2.概念模型的一种表示方法：实体-联系方法</p><ul><li>E-R方法也成为E-R模型</li></ul></li></ul><h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><ul><li>1.数据结构</li><li>2.数据操作</li><li>3.数据的完整性约束条件</li></ul><h3 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h3><ul><li><p>层次模型</p><ul><li><p>1.层次模型的数据结构</p><ul><li>（1）有且只有一个结点没有双亲结点，这个结点称为根结点；</li><li>（2）根以外的其他结点有且只有一个双亲结点。</li></ul></li><li><p>优点：</p><ul><li>（1）层次模型的数据结构比较简单清晰</li><li>（2）层次数据库的查询效率高</li><li>（3）层次模型提供了良好的完整性支持。</li></ul></li><li><p>缺点：</p><ul><li>（1）现实世界中很多联系时非层次性的，如结点之间具有多对多联系，不适合用层次模型表示。</li><li>（2）如果一个结点具有多个双亲结点，用层次模型表示这类联系就很笨拙。</li><li>（3）查询子女结点必须通过双亲结点。</li><li>（4）由于结构严密，层次命令趋于程序化。</li></ul></li></ul></li><li><p>网状模型</p><ul><li><p>数据结构</p><ul><li>（1）允许一个以上的结点无双亲。</li><li>（2）一个节点可以有多于一个的双亲。</li></ul></li><li><p>优点：</p><ul><li>（1）能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系。</li><li>（2）具有良好的性能，存取效率较高。</li></ul></li><li><p>缺点：</p><ul><li>（1）结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握。</li><li>（2）网状模型的DDL\DDM复杂，并且要嵌入某一种高级语言中，用户不容易掌握和使用。</li><li>（3）由于记录之间的联系时通过存取路径实现的，应用程序在访问数据时必须选择适当存取路径，因此用户必修了解系统结构的细节，加重了编写应用程序的负担。</li></ul></li></ul></li><li><p>关系模型</p><ul><li><p>数据结构</p><ul><li><p>关系</p><ul><li>一个关系对应通常说的一张表</li></ul></li><li><p>元组</p><ul><li>表中的一行即为一个元组</li></ul></li><li><p>属性</p><ul><li>表中的一列即为一个属性</li></ul></li><li><p>码</p><ul><li>也称码键。表中的某个属性组，它可以唯一确定一个元组。</li></ul></li><li><p>域</p><ul><li>域时一组具有相同数据类型的值的集合。属性的取值范围来自某个域。</li></ul></li><li><p>分量</p><ul><li>元组中的一个属性值</li></ul></li><li><p>关系模式</p><ul><li>对关系的描述，一般表示为  关系名（属性1，属性2，···，属性n）</li></ul></li></ul></li><li><p>数据操纵与完整性约束</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li><li>操作对象和操作结果都是关系</li></ul></li><li><p>优点：</p><ul><li>（1）关系模型与格式化模型不同，它是建立在严格的数学概念的基础上的。</li><li>（2）关系模型的概念单一。无论实体还是实体之间的联系都用关系来表示。对数据的建所和更新结果也是关系（即表）。所以其数据结构简单、清晰，用户易懂易用。</li><li>（3）关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。</li></ul></li><li><p>缺点：</p><ul><li>查询效率往往不如格式化数据模型</li></ul></li></ul></li></ul><h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><ul><li>在数据模型中有“型“（type）和”值“（value）的概念。模式时相对稳定的，而实例是相对变动的。</li></ul><h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><ul><li><p>1、模式</p><ul><li>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li></ul></li><li><p>2.外模式</p><ul><li>外模式也称子模式或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和他正的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li></ul></li><li><p>3.内模式</p><ul><li>内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</li></ul></li></ul><h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><ul><li><p>1.外模式/模式映像</p><ul><li>当模式改变时，由数据库管理员对各个外模式/模式的映像作相应的改变，可以时外模式保持不表。应用程序是依据数据的外模式编写的，从而应用程序不惜修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</li></ul></li><li><p>2.模式/内模式映像</p><ul><li>当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作相应改变，可以时模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性，简称数据的物理独立性。</li></ul></li></ul><h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><h3 id="1-硬件平台及数据库"><a href="#1-硬件平台及数据库" class="headerlink" title="1.硬件平台及数据库"></a>1.硬件平台及数据库</h3><ul><li>（1）要有足够大的内存，存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序。</li><li>（2）有足够大的磁盘或磁盘阵列等设备存放数据库，有足够大的磁带（或光盘）作数据备份。</li><li>（3）要求系统有较高的通道能力，以提高数据传送率。</li></ul><h3 id="2-软件"><a href="#2-软件" class="headerlink" title="2.软件"></a>2.软件</h3><ul><li>（1）数据库管理系统。</li><li>（2）支持数据库管理系统允许的操作系统</li><li>（3）具有与数据库接口的高级语言及其编译系统，便于开发应用程序</li><li>（4）以数据库管理系统为核心的应用开发工具。</li></ul><h3 id="3-人员"><a href="#3-人员" class="headerlink" title="3.人员"></a>3.人员</h3><ul><li>（1）数据库管理员</li><li>（2）系统分析员和数据库设计人员</li><li>（3）应用程序员</li><li>（40用户</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BCB连接Mysql数据库</title>
      <link href="2020/12/17/BCB%E8%BF%9E%E6%8E%A5Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2020/12/17/BCB%E8%BF%9E%E6%8E%A5Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近由于很多同学都在做软件工程实验，由于大部分同学使用BCB来进行软件开发，于是连接数据库就成了必须解决的问题，而本文的目的就是帮助大家用BCB连接Mysql数据库。</p></blockquote><h2 id="C-builder-6-0使用ODBC连接MySQL数据库"><a href="#C-builder-6-0使用ODBC连接MySQL数据库" class="headerlink" title="C++builder 6.0使用ODBC连接MySQL数据库"></a>C++builder 6.0使用ODBC连接MySQL数据库</h2><h3 id="1、检查数据库驱动"><a href="#1、检查数据库驱动" class="headerlink" title="1、检查数据库驱动"></a>1、检查数据库驱动</h3><p><strong>（win10）打开”控制面板”-&gt;“系统和安全”-&gt;“管理工具”-&gt;“ODBC数据源（64位）”</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/108109a754e4d5cb177a4bb5a0f48319.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/f2f7771ab3350f88e920da06da7c7003.png"></p><p>可以看到我的电脑目前还未装MySQL的数据驱动。</p><p>驱动百度网盘下载地址   <a href="https://pan.baidu.com/s/14-HY2yFH7mwlvzqn4g1fRg">下载地址</a>    提取码: 1fsr </p><h3 id="2、驱动安装"><a href="#2、驱动安装" class="headerlink" title="2、驱动安装"></a>2、驱动安装</h3><p>下载完成后，我们打开压缩包是这样的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/5569edb63fbde16c65753b9c0deb77f0.png"></p><p>第一个是32位安装包，第二个是64位安装包。</p><p><del>目前我们的电脑大多数是64位的，所以我们安装64位的驱动。</del></p><p>我他妈服了，原来BCB 6.0是32位的软件，所以我们驱动必须装32位的，bcb才能读取到</p><ul><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/106dbe638b25db0b6849dc7e2259618d.png"></p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/c79202b5d78335146dd50629825414fc.png"></p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/0f02c24d7ead01f0bd2dbe60bf405a23.png"></p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/ea8a3f82a634db702459382351e2a86b.png"></p></li></ul><p><strong>无脑点next就可以安装了，如果不想装在C盘，可以在倒数第二步选择Custom安装模式</strong></p><h3 id="3、添加驱动"><a href="#3、添加驱动" class="headerlink" title="3、添加驱动"></a>3、添加驱动</h3><p>安装完成后，我们再去数据源管理程序，添加驱动。</p><ul><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/84a38353b71d3c45ad720d3445c90ce0.png">-</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/5f089135c9dbefea1bfc7f10bd4e0f94.png"></p></li></ul><p><strong>一定选择Unicode这个驱动，防止字符乱码</strong></p><p>点完成后，进入下面的界面。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/7811b3d8a37e486095eaba1013fbd228.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/759bcbd7ef335c413f7bd9dadb0b2b0e.png"></p><p>点击test测试，结果连接成功，说明设置成功，点击OK，就设置完成了。</p><h3 id="4、C-builder中连接数据库"><a href="#4、C-builder中连接数据库" class="headerlink" title="4、C++builder中连接数据库"></a>4、C++builder中连接数据库</h3><p>1、打开一个项目</p><p>2、建立连接</p><ul><li>首先拖拽一个ADOConnection组件到窗口上。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/21bde94a024542bb16f6a80666fabdb6.png"></p><ul><li>双击ADOConnection组件，出现以下界面，然后点建立</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/6f740d0a3fad32e2a65cc712944e91c7.png"></p><ul><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/7bb50d66e0a24f3e2cc4c8fab1732771.png"></p><p>选择此选项然后下一步</p></li></ul><p>  数据源选择 ：这里我们选择，前面在ODBC数据源里设置的那个连接。</p><p>  <img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/c545735efb3e3e09ac1b4c94d88a1609.png"></p><ul><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/8b93088e1a15e6bde7c97efc95147f39.png"></p></li><li><p>信息输入完成后，点击连接测试，不出意外的话就连接成功了。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/4abf73a29d9dac7f12d8081b933ceb32.png"></p></li></ul><p>3、执行查询</p><p>查询我们使用到了ADOQuery组件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/6de70db0a58212b9685795de4c6fca1b.png"></p><p>然后点击ADOQuery组件的属性，Connection属性选择Connection1组件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/17/622187a0b3145b234474c149e7e7a823.png"></p><p>这样这个ADOQuery1组件就能使用了。</p><p>查询代码语法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADOQuery1-&gt;Close();<span class="comment">//关闭原来的查询</span></span><br><span class="line">ADOQuery-&gt;SQL-&gt;Clear();<span class="comment">//清空原来的SQL命令</span></span><br><span class="line">String sql = <span class="string">&quot;select *from student&quot;</span>;</span><br><span class="line">ADOQuery-&gt;SQL-&gt;Add(sql);<span class="comment">//添加命令</span></span><br><span class="line">ADOQuery.Open();<span class="comment">//执行SQL语句返回结果</span></span><br></pre></td></tr></table></figure><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>​    整个连接MySQL数据库过程就这样啦，只要一步步操作就不会有错的，如果以上操作有任何问题可以直接联系博主。</p>]]></content>
      
      
      
        <tags>
            
            <tag> BCB </tag>
            
            <tag> 数据库连接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一切都是对象</title>
      <link href="2020/12/09/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/12/09/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界。”</p></blockquote><h2 id="2-1-用引用操作对象"><a href="#2-1-用引用操作对象" class="headerlink" title="2.1 用引用操作对象"></a>2.1 用引用操作对象</h2><p>​    在Java中一切都被视为对象，因此可采用单一固定的语法。尽管一切都看作对象，但操纵的标识符实际上是对象的一个<strong>“引用（reference）”</strong>。可以将这一情形想象成用遥控器 <strong>（引用）</strong>来操纵电视机<strong>（对象）</strong>。当有人想改变频道或者减小音量时，实际操控的是2遥控器<strong>（引用）</strong>，再由遥控器来调控电视机<strong>（对象）</strong>。</p><blockquote><p>​    此外，即使没有电视机，遥控器亦可独立存在。也就是说，你拥有一个引用，并不一定需要有一个对象与它关联。</p></blockquote><h2 id="2-2-必须由你创建所有对象"><a href="#2-2-必须由你创建所有对象" class="headerlink" title="2.2 必须由你创建所有对象"></a>2.2 必须由你创建所有对象</h2><p>​    一旦创建了一个引用，就希望它能与一个新的对象相关联。通常用<strong>new</strong>操作符来实现这一目的。<strong>new</strong>关键字的意思是“给我一个新对象。”</p><h3 id="2-2-1存储到什么地方"><a href="#2-2-1存储到什么地方" class="headerlink" title="2.2.1存储到什么地方"></a>2.2.1存储到什么地方</h3><p>​    程序运行时，对象是怎么进行放置安排的呢？内存是怎样分配的呢？有五个不同的地方可以存储数据：</p><ul><li> 1）<strong>寄存器</strong>。这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（另一方面，C和C++允许您想编译器建议寄存器的分配方式）。</li><li>2）<strong>堆栈</strong>。位于通用RAM（随机访问存储器）中，但通过<em>堆栈指针</em>可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储与堆栈中——特别是对象引用，但是Java对象并不存储与期中。</li><li>3）<strong>堆</strong>。一种通用的内存池（也位于RAM区），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存货多长时间。因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需用<strong>new</strong>写一行简单的代码，当执行这行代码时，会自动在堆里分配和清理可能比用堆栈进行存储分配需要更多的世界（如果确实可以在Java中像在C++中一样在栈中创建对象）。</li><li>4）<strong>常量存储</strong>。常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分隔离开，所以在这种情况下，可以选择将其存放在ROM（只读存储器）中。</li><li>5）<strong>非RAM存储</strong>。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。期中两个基本的例子是*<strong>流对象**<em>和</em></strong>持久化对象***。在流对象中，对象转化成字节流，通常被发送给另一台机器。在“持久化对象”中，对象被存放于磁盘上，因此，即使程序终止，它们仍可以保持自己的状态。这种存储方式的技巧在于：把对象转化成可以存放在其他媒介上的食物，在需要时，可恢复成常规的、基于RAM的对象。Java提供了对轻量级持久化的支持，而诸如JDB和Hibernate这样的机制提供了更加复杂的对在数据库中存储和读取对象信息的支持。</li></ul><h3 id="2-2-2特例：基本类型"><a href="#2-2-2特例：基本类型" class="headerlink" title="2.2.2特例：基本类型"></a>2.2.2特例：基本类型</h3><p>​    在程序设计中经常用到一系列类型，它们需要特殊对待。可以把它们想象成“基本”类型。之所以特殊对待，是因为<strong>new</strong>将对象存储在“堆”里，故用<strong>new</strong>创建一个对象——特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，java采取与C和C++相同的方法。也就是说，不用<strong>new</strong>来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。</p><p>​    Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Java程序比用其他大多数语言编写的程序更具可移植性的原因之一。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/10/5fd06abb8a15eb74ad6faed8612809cd.png"></p><ul><li><p>所有数值类型都有正负号，所以不要去寻找无符号的数值类型。</p></li><li><p><strong>boolean</strong>类型所占存储空间的大小没有明确指定，仅定义为能够取字面值*<strong>true**<em>或</em></strong>false***。</p><p>基本类型具有的包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">Character ch = <span class="keyword">new</span> Character(c);</span><br><span class="line"><span class="comment">//也可以这样用：</span></span><br><span class="line">Character ch = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="comment">//并可以反向转换：</span></span><br><span class="line"><span class="keyword">char</span> c = ch;</span><br></pre></td></tr></table></figure><p><strong>高精度数字</strong></p><ul><li>Java提供了两个用于高精度计算的类：<strong>BigInteger</strong>和<strong>BigDecimal</strong>。虽然它们大体上属于“包装器类”的范畴，但二者都没有对应的基本类型。</li></ul></li><li><p>不过，这两个类包含的方法，提供的操作与基本类型所能执行的操作相似。也就是说，能作用于<strong>int</strong>或<strong>float</strong>的操作，也同样作用于<strong>BigInteger</strong>或<strong>BigDecimal</strong>。只不过必须以方法调用方式取代运算符方式来实现。由于这么做复杂了许多，所以运算速度会比较慢。在这里，以速度换取了精度。</p><ul><li><strong>BigInteger</strong>支持任意精度的整数。也就是说，在运算中，可以准确地表示任何大小的整数值，而不会丢失任何信息。</li></ul></li><li><p><strong>BigDecimal</strong>支持任何精度的定点数，例如，可以用它进行精确的货币计算。</p></li></ul><h3 id="2-2-3Java中的数组"><a href="#2-2-3Java中的数组" class="headerlink" title="2.2.3Java中的数组"></a>2.2.3Java中的数组</h3><ul><li><p>Java的主要目标之一是安全性，所以许多在C和C++里困扰程序员的问题在Java里不会再出现。Java确保数组会被初始化，额日期额不能在它的范围之外被访问。这种范围检查，是以每个数组上少量的内存开销及运行时的下标检查为代价的。但由此换来的是安全性和效率的提高，因此付出的代价是值得的（并且Java有时可以优化这些操作）。</p></li><li><p>当创建一个数组对象时，实际上就是创建了一个引用数组，并且每个引用都会自动被初始化为一个特定值，改值拥有自己的关键字<strong>null</strong>。一旦Java看到<strong>null</strong>，就知道这个引用还没有指向某个对象；如果试图使用一个还是<strong>null</strong>的引用，在运行时将会报错。因此，常犯的数组错误在Java中就可以避免。</p></li></ul><h2 id="2-3永远不需要销毁对象"><a href="#2-3永远不需要销毁对象" class="headerlink" title="2.3永远不需要销毁对象"></a>2.3永远不需要销毁对象</h2><blockquote><p>在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作中非常重要的部分。</p></blockquote><h3 id="2-3-1作用域"><a href="#2-3-1作用域" class="headerlink" title="2.3.1作用域"></a>2.3.1作用域</h3><p>​    大多数过程型语言都有**<em>作用域（scope）**</em>的概念。作用域决定了在其内定义的变量名的可见性和生命周期。在C、C++和Java中，作用域由花括号的位置决定。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//这个花括号的作用域里只有x变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">96</span>;</span><br><span class="line">        <span class="comment">//这个花括号的作用域里既存在x变量也存在q变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处只能访问x变量</span></span><br><span class="line">    <span class="comment">//而不能访问q变量</span></span><br><span class="line">    <span class="comment">//作用域里定义的变量只可用于作用域结束之前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管以下代码在C和C++中是合法的，但是在Java中却不能这样书写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">96</span>;<span class="comment">//非法定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    编译器将会报告变量x已经定义过。所以，在C和C++里将一个较大作用域的变量”隐藏“起来的做法，在Java里是不允许的。因为Java设计者认为这样做会导致程序混乱。</p><h3 id="2-3-2对象的作用域"><a href="#2-3-2对象的作用域" class="headerlink" title="2.3.2对象的作用域"></a>2.3.2对象的作用域</h3><blockquote><p>Java对象不具备和基本类型一样的生命周期，当用<strong>new</strong>创建一个Java对象时，它可以存活于作用域之外。</p></blockquote><p>假如你采用以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String ;</span><br><span class="line">&#125;<span class="comment">//作用域终点</span></span><br></pre></td></tr></table></figure><p>引用s在作用域终点就消失了。然而，s指向的<strong>String</strong>对象仍继续占据内存空间。在这一小段代码中，我们无法在这个作用域之后访问这个对象，因为对它唯一的引用已超出了作用域的范围。</p><ul><li>事实证明，由<strong>new</strong>创建的对象，只要你需要，就会一直保留下去。这样，许多C++编程问题在Java中就完全消失了。在C++中，你不仅必须要确保对象的保留时间于你需要这些对象的时间一样长，而且还必须在你使用完它们之后，将其销毁。</li><li>这样也带来了一个问题。如果Java让对象继续存在，呢么靠什么才能防止这些对象填满内存空间，进而阻塞你的程序呢？这正是C++里可能会发生的问题。这也是Java神奇所在。java有一个**<em>垃圾回收器**</em>，用来监视用<strong>new</strong>创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供其他新的对象使用。也就是说，你根本不必担心内存回收的问题。你只需要创建对象，一旦不再需要，它们就会自行消失。这样做就消除了这类编程问题（即”内存泄漏“），这是由于程序员忘记释放内存而产生的问题。</li></ul><h3 id="2-4创建新的数据类型：类"><a href="#2-4创建新的数据类型：类" class="headerlink" title="2.4创建新的数据类型：类"></a>2.4创建新的数据类型：类</h3><p>​    如果一切都是对象，那么是什么决定了某一类对象的外观与行为呢?换句话说，是什么确定了对象的类型?你可能期望有一个名为“type” 的关键字，当然它必须还要有相应的含义。然而，从历史发展角度来看，大多数面向对象的程序设计语言习惯用关键字class来表示“我准备告诉你一种新类型的对象看起来像什么样子”。class这 个关键字(以后会频繁使用，本书以后就不再用粗体字表示)之后紧跟着的是新类型的名称。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATypeName</span> </span>&#123;<span class="comment">/* Class body goes here */</span>&#125;</span><br><span class="line"></span><br><span class="line">ATypeName a = <span class="keyword">new</span> ATypeName();</span><br></pre></td></tr></table></figure><h3 id="2-4-1字段和方法"><a href="#2-4-1字段和方法" class="headerlink" title="2.4.1字段和方法"></a>2.4.1字段和方法</h3><p>​    每个对象都有用来存储其字段的空间；普通字段不能在对象间共享。下面是一个具有某些字段的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataOnly</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">boolean</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尽管这个类除了存储数据之外什么也不能做，但是人就可以像下面这样创建它的一个对象：</span></span><br><span class="line">DataOnly data = <span class="keyword">new</span> DataOnly();</span><br><span class="line"><span class="comment">/*可以给字段赋值，但首先必须知道如何引用一个对象的成员。具体的实现为：在对象引用的名称之后紧接着一个据点，然后再接着是对象内部的成员名称：objectReference.member</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">data.i = <span class="number">47</span>;</span><br><span class="line">data.d = <span class="number">1.1</span>;</span><br><span class="line">data.b = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/*想修改的数据也有可能位于对象所包含的其他对象中。在这种情况下，只需要再使用链接句点即可。例如：*/</span></span><br><span class="line">myPlane.leftTank.capacity = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>​    <strong>基本成员默认值</strong></p><p>​    若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值，如下表所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/10/a4cc9b6290d5c7551507afa1afd2922a.png"></p><blockquote><p>然而上述确保初始化的方法并不适用于”局部“变量（即并非某个类的字段）。</p></blockquote><h2 id="2-5方法、参数和返回值"><a href="#2-5方法、参数和返回值" class="headerlink" title="2.5方法、参数和返回值"></a>2.5方法、参数和返回值</h2><p>​    Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分暴扣：名称、参数、返回值和方法体。下面是它最基本的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">methodName</span><span class="params">( <span class="comment">/* Argument list */</span> )</span></span>&#123;</span><br><span class="line">    <span class="comment">/* Method body */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>方法名和参数列表唯一地标识出某个方法。</strong></p><p>​    Java中的方法只能作为类的一部分来创建。方法只有通过对象才能被调用，且这个对象必须能执行这个方法调用。如果试图再某个对象上调用它并不具备的方法，那么再编译时就会得到一条错误消息。</p><h2 id="2-6构建一个Java程序"><a href="#2-6构建一个Java程序" class="headerlink" title="2.6构建一个Java程序"></a>2.6构建一个Java程序</h2><h3 id="2-6-1名字可见性"><a href="#2-6-1名字可见性" class="headerlink" title="2.6.1名字可见性"></a>2.6.1名字可见性</h3><ul><li>Java采用了一种全新的方法来避免上述所有问题。为了给一个类库生成不会与其他名字混淆的名字，Java设计者希望程序员反过来使用自己的Internet域名，因为这样可以保证它们肯定是独一无二的。由于我的域名是zhiqin.xyz,所以我的各种奇奇怪怪的应用工具类库就被命名为xyz.zhiqin.utility.foibles。反转域名后，句点就用来代表子目录的划分。</li></ul><blockquote><p>这种机制意味着所有的文件都能够自动存活于它们自己的名字空间内，而且同一个文件内的每个类都有唯一的标识符——Java语言本身已经解决了这个问题。</p></blockquote><h3 id="2-6-2运用其他构件"><a href="#2-6-2运用其他构件" class="headerlink" title="2.6.2运用其他构件"></a>2.6.2运用其他构件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*大多时候，我们使用与编译器附在一起的Java标准类库里的构件。有了这些构件，就不必写一长串的反转域名。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//这种一次导入一群类的方式更常用</span></span><br></pre></td></tr></table></figure><h3 id="2-6-3static关键字"><a href="#2-6-3static关键字" class="headerlink" title="2.6.3static关键字"></a>2.6.3static关键字</h3><ul><li><p>通常来说，当创建类时，就是在描述那个类的对象的外观与行为。除非用new创建那个类的对象，否则，实际上并未获得任何对象。执行new来创建对象时，数据存储空间才被分配，其方法才供外界调用。</p></li><li><p>有两种情形用上述方法是无法解决的。一种情形是，只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。另一种情形是，希望某个方法不与包含它的类的任何对象关联在一起。也就是说，即使没有创建对象，也能够调用这个方法。</p></li><li><p>通过static关键字可以满足这两方面的需要。当声明-一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即使从未创建某个类的任何对象，也可以调用其static方法或访问其static域。通常，你必须创建一个对象，并用它来访问数据或方法。因为非static域和方法必须知道它们一起运作的特定对象日。</p></li></ul><h2 id="2-7你的第一个Java程序"><a href="#2-7你的第一个Java程序" class="headerlink" title="2.7你的第一个Java程序"></a>2.7你的第一个Java程序</h2><p>​    最后，让我们编写第一个完整的程序。此程序开始是打印一个字符串，然后是打印当前日期，这里用到了Java标准库里的Date类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloDate.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line">        Ststem.out.println(<span class="string">&quot;Hello, it&#x27;s: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    类的名字必须和文件名相同。如果你像现在这样创建一个独立运行的程序，那么文件中必须存在某个类与该文件同名(否则，编译器会报错)，且那个类必须包含一个 名为main0的方法，形式如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，public关键字意指这是一个可由外部调用的方法(第5章将详细描述)。main()方法的参数是一个String对象的数组。在这个程序中并未用到args,但是Java编译器要求必须这样做，因为args要用来存储命令行参数。</p><h3 id="2-7-1编译和运行"><a href="#2-7-1编译和运行" class="headerlink" title="2.7.1编译和运行"></a>2.7.1编译和运行</h3><p>​    要编译、运行这个程序，首先要有一个Java开发环境（JDK：java development kit）。</p><p>​    去网上下载一个JDK安装包，然后安装好后，设置环境变量。（这些步骤不会可以百度）。</p><ul><li><p>1）打开cmd窗口</p></li><li><p>2）进入文件保存位置</p></li><li><p>3）输入下面代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloDate.java</span><br></pre></td></tr></table></figure><p>如果没报错的话，继续输入下面代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloDate</span><br></pre></td></tr></table></figure><p>接着，便可以看到程序中的消息和当天日期被输出。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彼岸图网壁纸爬取</title>
      <link href="2020/12/04/%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91%E5%A3%81%E7%BA%B8%E7%88%AC%E5%8F%96/"/>
      <url>2020/12/04/%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91%E5%A3%81%E7%BA%B8%E7%88%AC%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>本文章最初发布在<a href="https://zhiqin.xyz/">zhiqin’s Blog</a>，未经允许，任何人禁止转载！</p><p>前言:</p><blockquote><p>​    前段时间在捣鼓博客的时候，看到别人博客里的图片都很好看，于是自己也想去找些好看的图片插入到博客中。找来找去就找到了<a href="http://pic.netbian.com/">彼岸图网</a>(受害者登场)，一进去看到这么多好看的图片，就心想着要是把这些图片都下载下来就好了，于是就有了这个项目。</p></blockquote><hr><p><strong><em>PS：下载下来的图片并不是真正的4k壁纸，而是网站里的缩略图。</em></strong></p><h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><ul><li>Python版本<ul><li>Python 3.8.1</li></ul></li><li>Python的依赖库<ul><li>requests</li><li>lxml</li></ul></li><li>运行Python的idel（可选）<ul><li>pycharm</li></ul></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="运行界面"><a href="#运行界面" class="headerlink" title="运行界面"></a>运行界面</h3><h4 id="启动界面"><a href="#启动界面" class="headerlink" title="启动界面"></a>启动界面</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/10/d7ea3c55de76633e90044eaeb1348f3c.png"></p><h4 id="爬虫实验"><a href="#爬虫实验" class="headerlink" title="爬虫实验"></a>爬虫实验</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/10/2e760581108a79702448d0410d88b10c.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/10/dbb6461d9f7a3df0c1ba1d7648887f43.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/12/10/bfabe23c85e98537c082bcca3d917481.png"></p><p>实验之后发现爬取成功。oh耶✌！</p><p>由于等下还要上课，下次在分析这次项目的思路和代码。如果有需要源码的小伙伴可以联系博主（到留言板留言或者直接点联系博主）。</p><p>点击查看源码    —&gt;    <a href="https://github.com/hnkjdaxzzq/code/blob/main/bian_spider.py">源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 好看的壁纸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象导论</title>
      <link href="2020/11/26/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/"/>
      <url>2020/11/26/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来……除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。”</p><p>​                                                               ——Benjamin Lee Whorf （1897-1941）</p></blockquote><h2 id="1-1-抽象过程"><a href="#1-1-抽象过程" class="headerlink" title="1.1 抽象过程"></a>1.1 抽象过程</h2><p>​    所有编程语言都提供<strong>抽象机制</strong>。可以认为，人们所能够解决的问题的复杂性直接取决于抽象的类型和质量。 ”汇编语言是对底层机器的轻微抽象。接着出现的许多所谓“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。这些语言在汇编语言基础上有了大幅的改进，但是它们所作的主要抽象仍要求在解决问题 时要基于计算机的结构，而不是基于所要解决的问题的结构来考虑。</p><p>​    这些语言在汇编语言基础上有了大幅的改进，但是它们所作的主要抽象仍要求在解决问题 时要基于计算机的结构，而不是基于所要解决的问题的结构来考虑。程序员必须建立起在机器 模型（位于“解空间”内，这是你对问题建模的地方，例如计算机）和实际待解问题的模型 （位于“问题空间”内，这是问题存在的地方，例如一项业务）之间的关联。建立这种映射是费 力的，而且这不属于编程语言所固有的功能，这使得程序难以编写，并且维护代价高昂，同时也产生了作为副产物的整个“编程方法”行业。</p><p>​    另一种对机器建模的方式就是只针对待解问题建模。早期的编程语言，如LISP和APL,都 选择考虑世界的某些特定视图（分别对应于“所有问题最终都是列表”或者“所有问题都是算 法形式的”）。PROLOG则将所有问题都转换成决策链。此外还产生了基于约束条件编程的语言和专门通过对图形符号操作来实现编程的语言（后者被证明限制性过强）。这些方式对于它们所 要解决的特定类型的问题都是不错的解决方案，但是一旦超出其特定领域，它们就力不从心了。</p><p>​    Alan Kay曾经总结了第一个成功的面向对象语言、同时也是Java所基于的语言之一的 Smalltalk的五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式：</p><ul><li><p>1）<strong>万物皆为对象</strong>。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它 ,在自身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件（狗、建筑物、服务等），将其表示为程序中的对象。</p></li><li><p>2）<strong>程序是对象的集合</strong>，它们通过发送消息来告知彼此所要做的。要想请求一个对象，就必 须对该对象发送一条消息。更具体地说，可以把消息想像为对某个特定对象的方法的调用请求。</p></li><li><p>3）<strong>每个对象都有自己的由其他对象所构成的存储</strong>。换句话说，可以通过创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。</p></li><li><p>4）<strong>每个对象都拥有其类型</strong>。按照通用的说法，“每个对象都是某个类（class）的一个实例 （instance）w,这里“类”就是“类型”的同义词。每个类最重要的区别于其他类的特性就是 “可以发送什么样的消息给它。</p></li><li><p>5）<strong>某一特定类型的所有对象都可以接收同样的消息</strong>。这是一句意味深长的表述，你在稍后 便会看到。因为“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象 必定能够接受发送给“几何形”对象的消息。这意味着可以编写与“几何形”交互并自动处理 所有与几何形性质相关的事物的代码。这种可替代性（substitutabiUty是OOP中最强有力的概 念之一。</p><hr><p>​    Booch对对象提出了一个更加简洁的描述：<em>对象具有状态、行为和标识</em>。这意味着每一个对 象都可以拥有内部数据（它们给出了该对象的状态）和方法（它们产生行为），并且每一个对象都可以唯一地与其他对象区分开来，具体说来，就是每一个对象在内存中都有一个唯一的地址。</p></li></ul><h2 id="1-2-每个对象都有一个接口"><a href="#1-2-每个对象都有一个接口" class="headerlink" title="1.2 每个对象都有一个接口"></a>1.2 每个对象都有一个接口</h2><blockquote><p>亚里士多德大概是第一个深入研究类型（type）的哲学家，他曾提出过鱼类和鸟类这样的概 念。所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的类的一部分。</p></blockquote><p>这种思想被直接应用于第一个面向对象语言Simula-67,它在程序中使用基本关键字**<em>class**</em>来引入新的类型。</p><p>所以，尽管我们在面向对象程序设计中实际上进行的是创建新的数据类型，但事实上所有的面向对象程序设计语言都使用class这个关键词来表示数据类型。当看到类型一词时，可将其作为类来考虑，反之亦然。</p><p>因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型，例如所有浮点型数字具有相同的特性和行为集合。二者的差异在于，程序 员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。可以根据需求，通过添加新的数据类型来扩展编程语言。编程系统欣然接受新的类，并且像对待内置类型一样地照管它们和进行类型检査。</p><p>一旦类被建立，就可以随心所欲地创建类的任意个对象，然后去操作它们，就像它们是存 在于你的待求解问题中的元素一样。事实上，面向对象程序设计的挑战之一，就是在问题空间 囱 的元素和解空间的对象之间创建一对一的映射。</p><p>但是，怎样才能获得有用的对象呢？必须有某种方式产生对对象的请求，使对象完成各种任务，如完成一笔交易、 在屏幕上画图、打开开关等等。每个对象都只能满足某些请 求，这些请求由对象的接口（interface）所定义，决定接口的 便是类型。以电灯泡为例来做一个简单的比喻（如右图所示）：<img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/11/26/1463cc0bd62875c955ba1d78cdb34e78.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Light It = <span class="keyword">new</span> Light（）；</span><br><span class="line">It.on（）；</span><br></pre></td></tr></table></figure><p>接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码。 这些代码与隐藏的数据一起构成了实现。从过程型编程的观点来看，这并不太复杂。在类型中， 每一个可能的请求都有一个方法与之相关联，当向对象发送请求时，与之相关联的方法就会被 调用。此过程通常被概括为：向某个对象“发送消息”（产生请求），这个对象便知道此消息的 目的，然后执行对应的程序代码。</p><blockquote><p>有些人对此会区别对待，他们认为：类型决定了接口，而类是该接口的一个特定实现。</p></blockquote><p>上例中，类型/类的名称是<strong>Light,**特定的</strong>Light<strong>对象的名称是</strong>It,<strong>可以向</strong>Light**对象发出的请 求是：打开它、关闭它、将它调亮、将它调暗。你以下列方式创建了一个Light对象：定义这个对象的“引用”（It）,然后调用new方法来创建该类型的新对象。为了向对象发送消息，需要声 明对象的名称，并以圆点符号连接一个消息请求。从预定义类的用户观点来看，这些差不多就是用对象来进行设计的全部。</p><h2 id="1-3-每个对象都提供服务"><a href="#1-3-每个对象都提供服务" class="headerlink" title="1.3 每个对象都提供服务"></a>1.3 每个对象都提供服务</h2><p>当正在试图开发或理解一个程序设计时，最好的方法之一就是将对象想像为“服务提供者”。程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。你的目标就是去创建（或者最好是在现有代码库中寻找）能够提供理想的服务来解决问题的一系列对象。</p><p>将对象作为服务提供者看待是一件伟大的简化工具，这不仅在设计过程中非常有用，而且当其他人试图理解你的代码或重用某个对象时，如果他们看出了这个对象所能提供的服务的价值，它会使调整对象以适应其设计的过程变得简单得多。</p><h2 id="1-4-被隐藏得具体实现"><a href="#1-4-被隐藏得具体实现" class="headerlink" title="1.4 被隐藏得具体实现"></a>1.4 被隐藏得具体实现</h2><p>​    将程序开发人员按照角色分为类创建者（那些创建新数据类型的程序员）和客户端程序员（那些在其应用中使用数据类型的类消费者）是大有裨益的。</p><p>​    客户端程序员的目标是收集各种用 来实现快速应用开发的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，而隐藏其他部分。为什么要这样呢？因为如果加以隐藏，那么客户端程序员将不能够访问它，这意味着类创建者可以任意修改被隐藏的部分，而不用担心对其他任何人造成影响。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或不知内情的客户端程序员所毁坏，因此将实现隐藏起来可以减少程序bug。</p><p>​    访问控制的第一个存在原因就是让客户端程序员无法触及他们不应该触及的部分一这些部分对数据类型的内部操作来说是必需的，但并不是用户解决特定问题所需的接口的一部分。 这对客户端程序员来说其或是一项服务，因为他们可以很容易地看出哪些东西对他们来说很重要，而哪些东西可以忽略。</p><p>​    访问控制的第二个存在原因就是允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。例如，你可能为了减轻开发任务而以某种简单的方式实现了某个特定类， 但稍后发现你必须改写它才能使其运行得更快。如果接口和实现可以清晰地分离并得以保护， 那么你就可以轻而易举地完成这项工作。</p><p>Java用三个关键字在类的内部设定边界：*<strong>public**<em>、</em></strong>private, protected*<strong>。这些访问指定词 （access specifier）决定了紧跟其后被定义的东西可以被谁使用。**<em>public</em></strong>表示紧随其后的元素对任 何人都是可用的，而*<strong>private**<em>这个关键字表示除类型创建者和类型的内部方法之外的任何人都不能访问的元素。</em></strong>private*<strong>就像你与客户端程序员之间的一堵砖墙，如果有人试图访问**<em>private</em></strong>成员， 就会在编译时得到错误信息。*<strong>protected**<em>关键字与</em></strong>private*<strong>作用相当，差别仅在于继承的类可以访 问**<em>protected</em></strong>成员，但是不能访问**<em>private**</em>成员。稍后将会对继承进行介绍。</p><p>Java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。 这种权限通常被称为包访问权限，因为在这种权限下，类可以访问在同一个包（库构件）中的 其他类的成员，但是在包之外，这些成员如同指定了**<em>private**</em>一样。</p><h2 id="1-5-复用具体实现"><a href="#1-5-复用具体实现" class="headerlink" title="1.5 复用具体实现"></a>1.5 复用具体实现</h2><p>一旦类被创建并被测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。事实证明，这种复用性并不容易达到我们所希望的那种程度，产生一个可复用的对象设计需要丰 富的经验和敏锐的洞察力。但是一旦你有了这样的设计，它就可供复用。代码复用是面向对象程序设计语言所提供的最了不起的优点之一。</p><p>最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为“创建一个成员对象”。新的类可以由任意数量、任意类型的其他对象以.任意可以实现新的类中想要的功能的方式所组成。因为是在使用现有的类合成新 的类，所以这种概念被称为组合（composition）,如果组合是动态发生的，那么它通常被称为 聚合（aggregation）.组合经常被视为“has-a” （拥有）关系，就像我们常说的“汽车拥有引擎” 一样。</p><p>​    组合带来了极大的灵活性。新类的成员对象通常都被声明为**<em>private,**</em>使得使用新类的客户 端程序员不能访问它们。这也使得你可以在不干扰现客户端代码的情况下，修改这些成员。 也可以在运行时修改这些成员对象，以实现动态修改程序的行为。下面将要讨论的继承并不具 国 备这样的灵活性，因为编译器必须对通过继承而创建的类施加编译时的限制。</p><h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6 继承"></a>1.6 继承</h2><p>对象这种观念，本身就是十分方便的工具，使得你可以通过概念将数据和功能封装到一起, 因此可以对问题空间的观念给出恰当的表示，而不用受制于必须使用底层机器语言。这些概念 用关键字**<em>class**</em>来表示，它们形成了编程语言中的基本单位。</p><p>遗憾的是，这样做还是有很多麻烦：在创建了一个类之后，即使另一个新类与其具有相似的 功能，你还是得重新创建一个新类。如果我们能够以现有的类为基础，复制 它，然后通过添加和修改这个副本来创建新类那就要好多了。通过继承便可 以达到这样的效果，不过也有例外，当源类（被称为基类、超类或父类）发生变动时，被修改的“副本”（被称为导出类、继承类或子类）也会反映出这些变动。</p><p>​    类型不仅仅只是描述了作用于一个对象集合上的约束条件，同时还有与其他类型之间的关系。两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多的特性，并且可以处理更多的消息（或以不同的方式来处理消息）。继承使用基类型和导出类型的概念表示了这种类型之间的相似性。一个基类型包含其所有导出类型所共享的特性和行为。可以创建一个基类型来表示系统中某些对象的核心概念，从基类型中导出其他类型，来表示此核心可以被实现的各种不同方式。</p><p>​    以垃圾回收机为例，它用来归类散落的垃圾。“垃圾”是基类型，毎一件垃圾都有重最、价值等特性，可以被切碎、熔化或分解。在此基础上，可以通过添加额外的特性（例如瓶子有颜 色）或行为（例如铝罐可以被压碎，铁罐可以被磁化）导出更具体的垃圾类型。此外，某些行为可能不同（例如纸的价值取决于其类型和状态）。可以通过使用继承来构建一个类型层次结构, 以此来表示待求解的某种类型的问题。</p><p>​    第二个例子是经典的几何形的例子，这在计算机辅助设计系统或游戏仿真系统中可能被用到。 基类是几何形，毎一个几何形都具有尺寸、颜色、位置等，同时每一个几何形都可以被绘制、擦除、移动和着色等。在此基础上，可以导出（继承出）具体的几何形状——圆形、正方形、三角形等——每一种都具有额外的特性和行为，例如某些形状可以被翻转。某些行为可能并不相同，例如 计算几何形状的面积。类型层次结构同时体现了几何形状之间的相似性和差异性。</p><p>​    当继承现有类型时，也就创造了新的类型。这个新的类型不仅包括现有类型的所有成员（尽管**<em>private**</em>成员被隐藏了起来，并且不可访问），而且更重要的是它复制了基类的接口。也就是说,所有可以发送给基类对象的消息同时也可以发送给导出类对象。由于通过发送给类的消息的类型 可知类的类型，所以这也就意味着导出类与基类具有相同的类型。在前面的例子中，“一个圆形也 就是一个几何形”。通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛。</p><p>有两种方法可以使基类与导出类产生差异。第 一种方法非常直接：直接在导出类中添加新方法。 这些新方法并不是基类接口的一部分。这意味着基类不能直接满足你的所有需求，因此必需添加更多的方法。这种对继承简单而基本的使用方式，有时 对问题来说确实是一种完美的解决方式。但是，应该仔细考虑是否存在基类也需要这些额外方法的可 能性。这种设计的发现与迭代过程在面向对象程序 设计中会经常发生（如右中图所示）。</p><p>虽然继承有时可能意味着在接口中添加新方 法（尤其是在以**<em>extends**</em>关键字表示继承的Java中）， 但并非总需如此。第二种也是更重要的一种使导出类和基类之间产生差异的方法是改变现有基类的方法的行为，这被称之为覆盖（overriding）那个方法（如右下图所示）。要想覆盖某个方法，可以直接在导出类中创建该方法的新定义即可。你可以说此时，我正在使用相同的接口方法，但是我想在新类型中做些不同的事情。”</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/11/26/5c9a9cf54c227026c4b877493389d75d.png"></p><h3 id="1-6-1-“是一个”与“像是一个”关系"><a href="#1-6-1-“是一个”与“像是一个”关系" class="headerlink" title="1.6.1 “是一个”与“像是一个”关系"></a>1.6.1 “是一个”与“像是一个”关系</h3><p>·对于继承可能会引发某种争论：继承应该只覆盖基类的方法（而并不添加在基类中没有的 新方法）吗？如果这样做，就意味着导出类和基类是完全相同的类型，因为它们具有完全相同 的接口。结果可以用一个导出类对象来完全替代一个基类对象。这可以被视为纯粹替代，通常 .称之为替代原则。在某种意义上，这是一种处理继承的理想方式。我们经常将这种情况下的基 类与导出类之间的关系称为is-a（是一个）关系，因为可以说“一个圆形就是一个几何形状二 判断是否继承,就是要确定是否可以用is-a来描述类之间的关系，并使之具有实际意义。</p><p>有时必须在导出类型中添加新的接口元素，这样也就扩展了接口。这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法。这种情况我们可以描述is-like-a（像是一个）关系。新类型具有旧类型的接口，但是它还包含其他方法，所以不能说它们完全相同。以空调为例，假设房子里已经布线安装好了所有的冷气设备的控制器，也就是说，房子具备了让你控制冷气设备的接口。想像一下，如果空调坏了，你用一个既能制冷又能 制热的热力泵替换了它，那么这个热力泵就is∙like-a空调，但是它可以做更多的事。因为房子的控制系统被设计为只能控制冷气设备，所以它只能和新对象中的制冷部分进行通信。尽管新对象的接口已经被扩展了，但是现有系统除了原来接口之外，对其他东西一无所知。</p><p>​    当然，在看过这个设计之后，很显然会发现，制冷系统这个基类不够一般化，应该将其更 名为“温度控制系统”，使其可以包括制热功能，这样我们就可以套用替R原则了。这张图说明了在真实世界中进行设计时可能会发生的事情。</p><p>当你看到替代原则时，很容易会认为这种方式（纯粹替代）是唯一可行的方式，而且事实上，用这种方式设计是很好的。但是你会时常发现，同样显然的是你必须在导出类的接口中添加新方法。只要仔细审视，两种方法的使用场合应该是相当明显的。</p><h2 id="1-7-伴随多态的可互换对象"><a href="#1-7-伴随多态的可互换对象" class="headerlink" title="1.7 伴随多态的可互换对象"></a>1.7 伴随多态的可互换对象</h2><p>​    在处理类型的层次结构时，经常想把一个对象不当作它所属的特定类型来对待，而是将其当作其基类的对象来对待。这使得人们可以编写出不依赖于特定类型的代码。在“几何形”的 例子中，方法操作的都是泛化（generic）的形状，而不关心它们是圆形、正方形、三角形还是. 其他什么尚未定义的形状。所有的几何形状都可以被绘制、擦除和移动，所以这些方法都是直接对一个几何形对象发送消息；它们不用担心对象将如何处理消息。</p><p>​    但是，在试图将导出类型的对象当作其泛化基类型对象来看待时（把圆形看作是几何形， 把自行车看作是交通工具，把四鹤看作是鸟等等），仍然存在一个问题。如果某个方法要让泛化 几何形状绘制自己、让泛化交通工具行驶，或者让泛化的鸟类移动，那么编译器在编译时是不可能知道应该执行哪一段代码的。这就是关键所在：当发送这样的消息时，程序员并不想知道哪一段代码将被执行绘图方法可以被等同地应用于圆形、正方形、三角形，而对象会依据自身的具体类型来执行恰当的代码。</p><p>​    如果不需要知道哪一段代码会被执行，那么当添加新的子类型时，不需要更改调用它的方 法，它就能够执行不同的代码。因此，编译器无法精确地了解哪一段代码将会被执行，那么它该怎么办呢？例如，在下面的图中，*<strong>BirdController**<em>对象仅仅处理泛化的</em></strong>Bird*<strong>对象，而不了解它们的确切类型。从**<em>BirdController</em></strong>的角度看，这么做非常方便，因为不需要编写特别的代码来判 定要处理的*<strong>Bird**<em>对象的确切类型或其行为。当</em></strong>move（）*<strong>方法被调用时，即便忽略**<em>Bird</em></strong>的具体类型， 也会产生正确的行为*<strong>Goose*** （鹅）走、飞或游泳，*</strong>Penguin*** （企鹅）走或游泳,那么，这是如何发生的呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/hnkjdaxzzq/img@latest/2020/11/26/bad9b9489128c5c2d21afd716ca87fb7.png"></p><p><em>这个问题的答案，也是面向对象程序设计的最重要的妙诀：编译•器不可能产生传统意义上 的函数调用。一个非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定，这个术语 你可能以前从未听说过，可能从未想过函数调用的其他方式。这么做意味着编译器将产生对一 个具体函数名字的调用，而运行时将这个调用解析到将要被执行的代码的绝对地址。然而在 OOP中，程序直到运行时才能够确定代码的地址，所以当消息发送到一个泛化对象时，必须采 用其他的机制。</em></p><p>为了解决这个问题，面向对象程序设计语言使用了后期绑定的概念。当向对象发送消息时被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值 执行类型检査（无法提供此类保证的语言被称为是弱类型的），但是并不知道将被执行的确切 代码。</p><p>为了执行后期绑定，Java使用一小段特殊的代码来替代绝对地址调用。这段代码使用在对 象中存储的信息来计算方法体的地址（这个过程将在第8章中详述）。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知 .道对这条消息应该做些什么。</p><p>在某些语言中，必须明确地声明希望某个方法具备后期绑定属性所带来的灵活性（C++是 使用**<em>virtual**</em>关键字来实现的）。在这些语言中，方法在默认情况下不是动态绑定的。而在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。</p><p>​    再来看看几何形状的例子。整个类族(其中所有的类都基于相同的一致接口)在本章前面 已有图示。为了说明多态，我们要编写一段代码，它忽略类型的具体细节，仅仅和基类交互。 这段代码和具体类型信息是分离的(decoupled),这样做使代码编写更为简单，也更易于理解。 而且，如果通过继承机制添加一个新类型，例如*<strong>Hexagon*** (六边形)，所编写的代码对*</strong>Shape*** (几何形)的新类型的处理与对已有类型的处理会同样出色。正因为如此，可以称这个程序是可扩展的。</p><p>如果用Java来编写一个方法(后面很快你就会学习如何编写):</p><p><strong><em>void doSomething(Shape shape) (</em></strong></p><p><strong><em>shape.erase();</em></strong></p><p><strong><em>∕∕ …</em></strong></p><p><strong><em>shape.draw();</em></strong></p><p><strong><em>}</em></strong></p><p>这个方法可以与任何*<strong>Shape***对话，因此它是独立于任何它要绘制和擦除的对象的具体类型的。 如果程序中其他部分用到了 *</strong>doSomething()***方法：</p><p><strong><em>Circle circle = new Circle();</em></strong></p><p><strong><em>Triangle triangle = new Triangle();</em></strong></p><p><strong><em>Line line = new Line():</em></strong></p><p><strong><em>doSomething(ci rcle):</em></strong></p><p><strong><em>doSomething(tri angle);</em></strong></p><p><strong><em>doSomething(line):</em></strong></p><p>对**<em>doSomething()**</em>的调用会自动地正确处理，而不管对象的确切类型。 这是一个相当令人惊奇的诀窍。看看下面这行代码：</p><p><strong><em>doSomething(ci rcle):</em></strong></p><p>当*<strong>Circle**<em>被传入到预期接收</em></strong>Shape*<strong>的方法中，究竟会发生什么。由于**<em>Circle</em></strong>可以*<strong>doSomethingO*** 看作是*</strong>Shape,<strong><em>也就是说，</em></strong>doSomething()<strong><em>可以发送给</em></strong>Shape***的任何消息，Circle都可以接收，那 .叵|么，这么做是完全安全且合乎逻辑的。</p><p>把将导出类看做是它的基类的过程称为向上转型(upcasting)o转型(cast)这个名称的灵</p><p>感来自于模型铸造的塑模动作I而向上(up)这 个词来源于继承图的典型布局方式：通常基类在 顶部，而导出类在其下部散开。因此，转型为一 个基类就是在继承图中向上移动，即“向上转型” (如右图所示)。</p><p>一个面向对象程序肯定会在某处包含向上转 型，因为这正是将自己从必须知道确切类型中解</p><p>放出来的关健。让我们再看看**<em>doSomethingO**</em>中的代码:</p><p><strong><em>shape.erase();</em></strong></p><p><strong><em>// …</em></strong></p><p><strong><em>shape.draw();</em></strong></p><p>注意这些代码并不是说“如果是*<strong>Circle,**<em>请这样做：如果是</em></strong>Square,<strong><em>请那样做••••••”。如果编写了那种检査</em></strong>Shape*<strong>所有实际可能类型的代码，那么这段代码肯定是杂乱不堪的，而且在每次添加了Shape的新类型之后都要去修改这段代码。这里所要表达的意思仅仅是“你是一个**<em>Shape,</em></strong> 我知道你可以*<strong>erase()**<em>。和</em></strong>draw()***你自己，那么去做吧，但是要注意细节的正确性。”</p><p><strong><em>doSomething()</em></strong>的代码给人印象深刻之处在于，不知何故，它总是做了该做的。调用*<strong>Circle**<em>的</em></strong>draw*<strong>。方法所执行的代码与调用**<em>Square</em></strong>或*<strong>Line**<em>的</em></strong>draw()<strong>*法所执行的代码是不同的，而且当 *</strong>dmw()<strong><em>消息被发送给一个匿名的</em></strong>Shape*<strong>时，也会基于该**<em>Shape</em></strong>的实际类型产生正确的行为。这相 当神奇，因为就像在前面提到的，当Java编译器在编译*<strong>doSomething()**<em>的代码时，并不能确切知 道</em></strong>doSomething()<strong><em>要处理的确切类型。所以通常会期望它的编译结果是调用基类</em></strong>Shape*<strong>的**<em>erase</em></strong>。</p><p>和*<strong>draw()**<em>版本，而不是具体的</em></strong>Circle. Square*<strong>或**<em>Line</em></strong>的相应版本。正是因为多态才使得事情总是能够被正确处理。编译器和运行系统会处理相关的细节，你需要马上知道的只是事情会发生， 更重要的是怎样通过它来设计。当向一个对象发送消息时，即使涉及向上转型，该对象也知道要执行什么样的正确行为。</p><h2 id="1-8-单根继承结构"><a href="#1-8-单根继承结构" class="headerlink" title="1.8 单根继承结构"></a>1.8 单根继承结构</h2><p>​    在OOP中，自C++面世以来就已变得非常瞩目的一个问题就是，是否所有的类最终都继承 自单一的基类。在Java中(事实上还包括除C++以外的所有OOP语言)，答案是yes,这个终极基 类的名字就是**<em>Object**</em>。事实证明，单根继承结构带来了很多好处。</p><p>在单根继承结构中的所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类 型。另一种(C++所提供的)结构是无法确保所有对象都属于同一个基本类型。从向后兼容的 角度看，这么做能够更好地适应C模型，而且受限较少，但是当要进行完全的面向对象程序设计 时，则必须构建自己的继承体系，使得它可以提供其他OOP语言内置的便利。并且在所获得的 任何新类库中，总会用到一些不兼容的接口，需要花力气(有可能要通过多重继承)来使新接 口融入你的设计之中。这么做来换取C++额外的灵活性是否值得呢？如果需要的话——如果在C 上面投资巨大，这么做就很有价值。如果是刚刚从头开始那么像Java这样的选择通常会有更 髙的生产率。    、</p><p>单根继承结构保证所有对象都具备某些功能。由此你知道，在你的系统中你可以在每个对象 上执行某些基本操作。所有对象都可以很容易地在堆上创建，而参数传递也得到了极大的简化。</p><p>单根继承结构使垃圾回收器的实现变得容易得多，而垃圾回收器正是Java相对C++的重要改 进之一。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。 这对于系统级操作(如异常处理)显得尤其重要，并且给编程带来了更大的灵活性。</p><h2 id="1-9-容器"><a href="#1-9-容器" class="headerlink" title="1.9 容器"></a>1.9 容器</h2><h3 id="1-9-1-参数化类型"><a href="#1-9-1-参数化类型" class="headerlink" title="1.9.1 参数化类型"></a>1.9.1 参数化类型</h3><h2 id="1-10-对象的创建和生命期"><a href="#1-10-对象的创建和生命期" class="headerlink" title="1.10 对象的创建和生命期"></a>1.10 对象的创建和生命期</h2><h2 id="1-11-异常处理：处理错误"><a href="#1-11-异常处理：处理错误" class="headerlink" title="1.11 异常处理：处理错误"></a>1.11 异常处理：处理错误</h2><h2 id="1-12-并发编程"><a href="#1-12-并发编程" class="headerlink" title="1.12 并发编程"></a>1.12 并发编程</h2><h2 id="1-13-Java与Internet"><a href="#1-13-Java与Internet" class="headerlink" title="1.13 Java与Internet"></a>1.13 Java与Internet</h2><h3 id="1-13-1-客户端编程"><a href="#1-13-1-客户端编程" class="headerlink" title="1.13.1 客户端编程"></a>1.13.1 客户端编程</h3><h3 id="1-13-2-服务器端编程"><a href="#1-13-2-服务器端编程" class="headerlink" title="1.13.2 服务器端编程"></a>1.13.2 服务器端编程</h3>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第五章</title>
      <link href="2020/11/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>2020/11/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="5-总体设计"><a href="#5-总体设计" class="headerlink" title="5.总体设计"></a>5.总体设计</h1><h2 id="5-1设计过程"><a href="#5-1设计过程" class="headerlink" title="5.1设计过程"></a>5.1设计过程</h2><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><ul><li>从工程管理的角度，可以将软件设计分为概要设计阶段和详细设计阶段。</li><li>从技术的角度，传统的结构化方法将软件设计划分为体系结构设计、数据设计、接口设计和过程设计4部分。</li><li>面向对象方法则将软件设计划分为体系结构设计、类设计/数据设计、接口设计和构件级设计4部分。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/368eaddd2b5038b4a78ca51dda1f861b.png"></li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/ceb8eac59f58336726bb549af2b2a260.png"></li></ul><h3 id="基本任务"><a href="#基本任务" class="headerlink" title="基本任务"></a>基本任务</h3><ul><li>（1）将软件系统划分成模块</li><li>（2）决定每个模块的功能</li><li>（3）决定模块的调用关系</li><li>（4）决定模块的界面，即模块间传递的数据</li></ul><h3 id="总体设计的过程"><a href="#总体设计的过程" class="headerlink" title="总体设计的过程"></a>总体设计的过程</h3><ul><li><p>系统设计阶段，确定系统的具体实现方案</p><ul><li>设想供选择的方案</li><li>选取合理的方案</li><li>推荐最佳方案</li></ul></li><li><p>结构设计阶段，确定软件结构</p><ul><li>功能分解</li><li>设计软件结构</li><li>设计数据库</li></ul></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>1．设想供选择的方案</p><ul><li>根据需求分析阶段得出的数据流图考虑各种可能的实现方案，力求从中选出最佳方案。即由逻辑模型——&gt;物理模型</li></ul></li><li><p>2．选取合理的方案</p><ul><li><p>从前一步得到的一系列供选择的方案中选取若干个合理的方案。通常，选取的这些方案中至少应包括低成本、中成本和高成本的三种方案类型。对每个合理的方案分析员都应该准备下列4份资料：对每个合理方案要提供以下几方面资料：</p><ul><li>（1）系统流程图；</li><li>（2）组成系统的物理元素清单 ；</li><li>（3）成本／效益分析；</li><li>（4）实现这个系统的进度计划。</li></ul></li></ul></li><li><p>3．推荐最佳方案</p><ul><li>分析员从合理方案中选择一个最佳方案向用户推荐，并为推荐的方案制定详细的实现计划。对于分析员推荐的最佳方案，用户和有关专家应该认真审查。如果确认该方案确实符合用户的需要，并且在现有条件下完全能够实现，则应该提请使用部门负责人进一步审批。在使用部门负责人也接受了分析员所推荐的方案之后，方可进入总体设计过程的下一步工作，即结构设计阶段。</li></ul></li><li><p>4．功能分解</p><ul><li><p>（1）结构设计 —— 总体设计阶段的任务</p><ul><li>结构设计确定程序由哪些模块组成，以及这些模块之间的关系；</li></ul></li><li><p>（2）过程设计 —— 详细设计阶段的任务</p><ul><li>过程设计确定每个模块的处理过程。主要是按照用户的要求把复杂的功能从实现的角度进行分解，以方便后面软件结构的确定</li></ul></li></ul></li><li><p>5.设计软件结构</p><ul><li>通常程序中的一个模块完成一个适当的子功能。应该把模块组织成良好的层次系统。软件结构可以用层次图或结构图来描绘。</li><li>如果数据流图已经细化到适当的层次，则可以直接从数据流图映射出软件结构，这就是面向数据流的设计方法。</li></ul></li><li><ol start="6"><li>设计数据库</li></ol><ul><li><p>数据库设计的主要工作是：</p><ul><li>1）设计数据库的表，表的结构就是数据的存储结构</li><li>2）对这些表中的数据进行操作。</li></ul></li><li><p>数据库设计的主要挑战是“高速度处理大容量的数据”</p></li><li><p>数据库设计的步骤:</p><ul><li>逻辑设计</li><li>物理设计</li><li>安全性设计</li><li>性能优化</li></ul></li></ul></li><li><p>7．制定测试计划</p><ul><li>在软件开发的早期阶段提前考虑软件的测试计划是很有必要的。这样能促使软件设计人员在设计时注意到软件的测试问题，从而有利于提高软件的可测试性。 </li></ul></li><li><p>8．书写文档</p><ul><li>（1）总体设计说明书（包括系统实现方案和软件模块结构）；</li><li>（2）测试计划（包括测试策略、测试方案、预测的测试结果、测试进度计划等）；</li><li>（3）用户手册（根据总体设计阶段的结果，编写的初步的用户操作手册）；</li><li>（4）详细的实现计划；</li><li>（5）数据库设计结果。</li></ul></li><li><ol start="9"><li>审查和复审</li></ol><ul><li>最后应该对总体设计的结果进行严格的技术审查，在技术审查通过之后再由使用部门的负责人从管理角度进行复审。</li></ul></li></ul><h2 id="5-2设计原理"><a href="#5-2设计原理" class="headerlink" title="5.2设计原理"></a>5.2设计原理</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li><p>定义：</p><ul><li>模块是数据说明、可执行语句等程序对象的集合，它是单独命名的，可通过名字来进行访问。</li></ul></li><li><p>特点：</p><ul><li>一个模块具有输入和输出、功能、内部数据和程序代码等四个特性。</li><li>输入输出和功能构成一个模块的外貌，即模块的外部特性。</li><li>内部数据和程序代码是模块的内部特性。</li></ul></li><li><p>模块化</p><ul><li>模块化就是把程序划分成若干个模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能，满足用户的需求</li><li>特点：先分解，然后再集成</li><li>软件模块化设计的指导思想是分解、抽象、逐步求精、信息隐蔽和模块独立性。</li></ul></li><li><p>为什么要模块化？</p><ul><li>模块化是为了使一个复杂的大型程序能被人的智力所管理，软件应该具备的惟一属性。</li><li>如果一个大型程序仅由一个模块组成，它将很难被人所理解。</li></ul></li><li><p>评价一种设计方法定义模块能力的五条标准：</p><ul><li>模块可分解性     </li><li>模块可组装性 </li><li>模块可理解性</li><li>模块连续性 </li><li>模块保护性</li></ul></li><li><p>模块化的作用：</p><ul><li>采用模块化原理可以使软件结构清晰，不仅容易设计也容易阅读和理解。</li><li>模块化使软件容易测试和调试，因而有助于提高软件的可靠性。</li><li>模块化能够提高软件的可修改性。</li><li>模块化也有助于软件开发工程的组织管理。</li></ul></li></ul><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><ul><li><p>定义</p><ul><li>现实世界中一定事物、状态或过程之间总存在着某些相似的方面(共性)。把这些相似的方面集中和概括起来，暂时忽略它们之间的差异，这就是抽象。</li><li>抽象就是抽出事物本质特性而暂时不考虑细节。</li></ul></li><li><p>一般抽象过程：</p><ul><li>处理复杂系统的惟一有效的方法是用层次的方式构造和分析它。</li><li>一个复杂的动态系统首先可以用一些高级的抽象概念构造和理解，这些高级概念又可以用一些较低级的概念构造和理解，如此进行下去，直至最低层次的具体元素。 </li><li>例：过程抽象、数据抽象</li></ul></li><li><p>软件工程抽象过程：</p><ul><li>软件工程过程的每一步都是对软件解法的抽象层次的一次精化。</li><li>在可行性研究阶段，软件作为系统的一个完整部件</li><li>在需求分析阶段，软件解法是使用在问题环境内熟悉的方式描述</li><li>进入总体设计向详细设计过渡阶段，抽象的程度将随之减少</li><li>最后当源程序被写出以后，抽象就达到最低层。</li></ul></li></ul><h3 id="逐步求精"><a href="#逐步求精" class="headerlink" title="逐步求精"></a>逐步求精</h3><ul><li><p>介绍：</p><ul><li>为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。逐步求精是人类解决复杂问题时采用的基本方法，也是许多软件工程技术的基础。</li></ul></li><li><p>Miller法则：</p><ul><li>一个人在任何时候都只能把注意力集中在（7±2）个知识块上。</li></ul></li><li><p>抽象与求精的关系</p><ul><li>抽象与求精是一对互补的概念。抽象使得设计者能够说明过程和数据，同时却忽略低层细节。求精则帮助设计者在设计过程中逐步揭示出低层细节。</li></ul></li><li><p>逐步求精的作用：</p><ul><li>它能帮助软件工程师把精力集中在与当前开发阶段最相关的那些方面上，而忽略那些对整体解决方案来说虽然是必要的，然而目前还不需要考虑的细节。</li><li>逐步求精方法确保每个问题都将被解决，而且每个问题都将在适当的时候被解决，但是，在任何时候一个人都不需要同时处理7个以上知识块。</li></ul></li></ul><h3 id="信息隐藏和局部化"><a href="#信息隐藏和局部化" class="headerlink" title="信息隐藏和局部化"></a>信息隐藏和局部化</h3><ul><li><p>信息隐藏原理：</p><ul><li>应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。</li></ul></li><li><p>局部化：</p><ul><li>局部化的概念和信息隐藏概念是密切相关的。所谓局部化是指把一些关系密切的软件元素物理地放得彼此靠近。显然，局部化有助于实现信息隐藏。</li></ul></li><li><p>作用：</p><ul><li>“隐藏”意味着有效的模块化可以通过定义一组独立的模块而实现，这些独立的模块彼此间仅仅交换那些为了完成系统功能而必须交换的信息。</li><li>使用信息隐藏原理作为模块化系统设计的标准就会带来极大好处。因为绝大多数数据和过程对于软件的其他部分而言是隐藏的，在修改期间由于疏忽而引入的错误就很少可能传播到软件的其他部分。</li></ul></li></ul><h3 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h3><ul><li><p>定义：</p><ul><li>模块独立的概念是模块化、抽象、信息隐藏和局部化概念的直接结果。</li><li>希望这样设计软件结构，使得每个模块完成一个相对独立的特定子功能，并且和其他模块之间的关系很简单。 </li></ul></li><li><p>模块独立的重要性：</p><ul><li>有效的模块化(即具有独立的模块)的软件比较容易开发出来。这是由于能够分割功能而且接口可以简化，当许多人分工合作开发同一个软件时，这个优点尤其重要。</li><li>独立的模块比较容易测试和维护。这是因为相对说来，修改设计和程序需要的工作量比较小，错误传播范围小，需要扩充功能时能够“插入”模块。</li></ul></li><li><p>模块独立程度的两个定性标准度量：</p><ul><li>耦合衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低，即每个模块和其他模块之间的关系要简单；</li><li>内聚衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高，每个模块完成一个相对独立的特定子功能。</li><li>模块独立性愈高，则块内联系越强（内聚性强/高），块间联系越弱（耦合度弱/低）。</li></ul></li><li><p>耦合——块间联系</p><ul><li>耦合：是对一个软件结构内不同模块之间互连程度的度量。</li><li>要求：在软件设计中应该追求尽可能松散耦合的系统。</li><li>可以研究、测试或维护任何一个模块，而不需要对系统的其他模块有很多了解；</li><li>模块间联系简单，发生在一处的错误传播到整个系统的可能性就很小；</li><li>模块间的耦合程度强烈影响系统的可理解性、可测试性、可靠性和可维护性。</li></ul></li><li><p>耦合程度的度量：</p><ul><li><p>(1) 非直接耦合/完全独立</p><ul><li>如果两个模块中的每一个都能独立地工作而不需要另一个模块的存在，那么它们完全独立。</li><li>在一个软件系统中不可能所有模块之间都没有任何连接。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/cd690936362cc449c8c172ff8af81366.png"></li></ul></li><li><p>(2) 数据耦合</p><ul><li><p>如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/f7193282ed9c4e9463a0424b4f6309b6.png"></p></li><li><p>评价：</p><ul><li>系统中至少必须存在这种耦合。一般说来，一个系统内可以只包含数据耦合。</li><li>数据耦合是理想的目标。</li><li>维护更容易，对一个模块的修改不会是另一个模块产生退化错误。</li></ul></li></ul></li><li><p>(3) 控制耦合</p><ul><li><p>如果两个模块彼此间传递的信息中有控制信息，这种耦合称为控制耦合。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/5228fea9d02ddf5b08cfb8eda4983d46.png"></p></li><li><p>评价：</p><ul><li>控制耦合往往是多余的，把模块适当分解之后通常可以用数据耦合代替它。</li><li>被调用的模块需知道调用模块的内部结构和逻辑，降低了重用的可能性 。</li></ul></li></ul></li><li><p>(4) 特征耦合</p><ul><li><p>当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。</p></li><li><p>评价：</p><ul><li>被调用的模块可使用的数据多于它确实需要的数据，这将导致对数据的访问失去控制，从而给计算机犯罪提供了机会。</li><li>无论何时把指针作为参数进行传递，都应该仔细检查该耦合。</li></ul></li></ul></li><li><p>(5) 公共环境耦合</p><ul><li><p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等等。</p></li><li><p>公共环境耦合的类型：</p><ul><li><p>一个模块往公共环境送数据，另一个模块从公共环境取数据。数据耦合的一种形式，是比较松散的耦合。</p></li><li><p>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/858abea9497815abf58cbcaa58e0a037.png"></p></li><li><p>评价：</p><ul><li>与结构化编程矛盾，生成的代码完全不可读。</li><li>如果在一个模块中对一个全局变量的声明进行修改，必须修改能够访问该全局变量的每一个模块。</li><li>公共环境耦合的模块难于重用，必须提供一个全局变量的清单。</li><li>即使模块本身不改变，它和产品中其他模块之间公共环境耦合的实例数也会变化非常大。</li><li>潜在危险很大。模块暴露出必需要更多的数据，难以控制数据存取，而且会导致计算机犯罪。</li><li>有些情况下公共环境耦合更好。 </li></ul></li></ul></li></ul></li><li><p>(6) 内容耦合</p><ul><li><p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合：</p><ul><li>一个模块访问另一个模块的内部数据；</li><li>一个模块不通过正常入口转到另一个模块的内部；</li><li>两个模块有一部分程序代码重叠；</li><li>一个模块有多个入口。 </li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/1a8d73a9ea1d48b0b04ceb838f88580c.png"></li></ul></li></ul></li><li><p>设计原则：</p><ul><li>尽量使用数据耦合，</li><li>少用控制耦合和特征耦合，</li><li>限制公共环境耦合的范围。</li><li>完全不用内容耦合</li></ul></li></ul></li><li><p>内聚——块内联系</p><ul><li>内聚：标志一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然扩展。简单地说，理想内聚的模块只做一件事情。</li><li>要求：设计时应该力求做到高内聚，通常中等程度的内聚也是可以采用的，而且效果和高内聚相差不多；但是，低内聚不要使用。</li><li>内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。 </li></ul></li><li><p>内聚程度的度量：</p><ul><li><p>(1) 偶然内聚</p><ul><li><p>如果一个模块完成一组任务，这些任务彼此间即使有关系，关系也是很松散的，就叫做偶然内聚。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/eedfd07976671a946502416f4349c0ee.png"></p></li><li><p>评价：</p><ul><li>模块内各元素之间没有实质性联系，很可能在一种应用场合需要修改这个模块，在另一种应用场合又不允许这种修改，从而陷入困境；</li><li>可理解性差，可维护性产生退化；</li><li>模块是不可重用的。</li></ul></li><li><p>解决方案：</p><ul><li>将模块分成更小的模块，每个小模块执行一个操作。</li></ul></li></ul></li><li><p>(2) 逻辑内聚</p><ul><li><p>如果一个模块完成的任务在逻辑上属于相同或相似的一类，则称为逻辑内聚。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/814e1d65fb5b5fa7d84f50176883faff.png"></p></li><li><p>评价：</p><ul><li>接口难以理解，造成整体上不易理解；</li><li>完成多个操作的代码互相纠缠在一起，即使局部功能的修改有时也会影响全局，导致严重的维护问题；</li><li>难以重用。</li></ul></li><li><p>解决方案：</p><ul><li>模块分解。 </li></ul></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/409ca6a009821cf40d8757d5a963bae5.png"></p></li></ul></li><li><p>(3) 时间内聚</p><ul><li><p>如果一个模块包含的任务必须在同一段时间内执行，就叫时间内聚。</p></li><li><p>评价：</p><ul><li>时间关系在一定程度上反映了程序某些实质，所以时间内聚比逻辑内聚好一些。</li><li>模块内操作之间的关系很弱，与其他模块的操作却有很强的关联。</li><li>时间内聚的模块不太可能重用。</li></ul></li></ul></li><li><p>(4) 过程内聚</p><ul><li><p>如果一个模块内的处理元素是相关的，而且必须以特定次序执行，则称为过程内聚。</p></li><li><p>使用程序流程图作为工具设计软件时，常常通过研究流程图确定模块的划分，这样得到的往往是过程内聚的模块。 </p></li><li><p>评价：</p><ul><li>比时间内聚好，至少操作之间是过程关联的。</li><li>仍是弱连接，不太可能重用模块。</li></ul></li><li><p>解决方案：</p><ul><li>分割为单独的模块，每个模块执行一个操作。</li></ul></li></ul></li><li><p>(5) 通信内聚</p><ul><li><p>如果模块中所有元素都使用同一个输入数据和(或)产生同一个输出数据，则称为通信内聚。即在同一个数据结构上操作。</p></li><li><p>评价：</p><ul><li>模块中各操作紧密相连，比过程内聚更好。</li><li>不能重用。</li></ul></li><li><p>解决方案：</p><ul><li>分成多个模块，每个模块执行一个操作。</li></ul></li></ul></li><li><p>(6) 顺序内聚</p><ul><li><p>如果一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚。</p></li><li><p>评价：</p><ul><li>根据数据流图划分模块时，通常得到顺序内聚的模块，这种模块彼此间的连接往往比较简单。 </li></ul></li></ul></li><li><p>(7) 功能内聚</p><ul><li><p>如果模块内所有处理元素属于一个整体，完成一个单一的功能，则称为功能内聚。功能内聚是最高程度的内聚。</p></li><li><p>评价：</p><ul><li>模块可重用，应尽可能重用；</li><li>可隔离错误，维护更容易；</li><li>扩充产品功能时更容易。</li></ul></li></ul></li><li><p>七种内聚的优劣评分结果：</p><ul><li><p>高内聚：</p><ul><li>功能内聚     10分</li><li>顺序内聚        9分        </li></ul></li><li><p>中内聚：</p><ul><li>通信内聚          7分    </li><li>过程内聚          5分</li></ul></li><li><p>低内聚：</p><ul><li>时间内聚        3分</li><li>逻辑内聚        1分</li><li>偶然内聚        0分</li></ul></li></ul></li><li><p>总结：</p><ul><li>设计时力争做到高内聚，并且能够辨认出低内聚的模块。对于一个模块而言，模块自身的内聚越强，模块间的耦合就越小，模块所具有的独立性就越好，可以说高内聚低耦合是我们进行软件设计的一贯原则。</li></ul></li></ul></li></ul><h2 id="5-3启发规则"><a href="#5-3启发规则" class="headerlink" title="5.3启发规则"></a>5.3启发规则</h2><h3 id="1-改进软件结构提高模块独立性"><a href="#1-改进软件结构提高模块独立性" class="headerlink" title="1. 改进软件结构提高模块独立性"></a>1. 改进软件结构提高模块独立性</h3><ul><li><p>通过模块分解或合并，降低耦合提高内聚。</p><ul><li>例如，多个模块公有的一个子功能可以独立成一个模块，由这些模块调用；有时可以通过分解或合并模块以减少控制信息的传递及对全程数据的引用，并且降低接口的复杂程度。</li></ul></li><li><p>两个方面：</p><ul><li><p>模块功能完善化。一个完整的模块包含：</p><ul><li>执行规定的功能的部分</li><li>出错处理的部分</li><li>返回一个“结束标志”</li></ul></li><li><p>消除重复功能，改善软件结构。</p><ul><li><p>完全相似</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/0a77666bf80fa10165553c27daea43e0.png"></li></ul></li><li><p>局部相似</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/cebb572ff17fa518a9667e91373929a4.png"></li></ul></li></ul></li></ul></li></ul><h3 id="2-模块规模应该适中"><a href="#2-模块规模应该适中" class="headerlink" title="2. 模块规模应该适中"></a>2. 模块规模应该适中</h3><ul><li>经验表明，一个模块的规模不应过大，最好能写在一页纸内。通常规定50~100行语句，最多不超过500行。数字只能作为参考，根本问题是要保证模块的独立性。</li><li>过大的模块往往是由于分解不充分，但是进一步分解必须符合问题结构，一般说来，分解后不应该降低模块独立性。</li><li>过小的模块开销大于有效操作，而且模块数目过多将使系统接口复杂。</li></ul><h3 id="3-深度、宽度、扇出和扇入应适中"><a href="#3-深度、宽度、扇出和扇入应适中" class="headerlink" title="3. 深度、宽度、扇出和扇入应适中"></a>3. 深度、宽度、扇出和扇入应适中</h3><ul><li>深度: 表示软件结构中控制的层数，它往往能粗略地标志一个系统的大小和复杂程度。深度和程序长度之间应该有粗略的对应关系。</li><li>宽度: 表示软件结构中控制的总跨度。即同一个层次上的模块总数的最大值，宽度越大系统越复杂。</li><li>扇出：表示一个模块直接控制(调用)的模块数目。扇出为3－4，上限扇出为5－9。</li><li>扇入：表示有多个上级模块直接调用该模块，扇入越大则共享该模块的上级模块数目越多。</li><li>软件结构一般要求顶层扇出较大，中层扇出较少，底层扇入较大为好。</li></ul><h3 id="4-模块的作用域应该在控制域之内"><a href="#4-模块的作用域应该在控制域之内" class="headerlink" title="4. 模块的作用域应该在控制域之内"></a>4. 模块的作用域应该在控制域之内</h3><ul><li><p>模块的作用域是指受该模块内一个判定影响的所有模块的集合。</p></li><li><p>模块的控制域是包括自己以及所有下属模块的集合。</p></li><li><p>在一个设计得很好的系统中，所有受判定影响的模块应该都从属于做出判定的那个模块，最好局限于做出判定的那个模块本身及它的直属下级模块。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/716dbec7703b75bcd3c3335882982256.png"></p><ul><li>第一，这种结构使得软件难于理解</li><li>第二，为了能影响到G，需要在A中设置标记，并把标记传递给M（A和G的公共上级），再由M传递给G。这个标记是控制信息不是数据，将使得模块间出现控制耦合。</li></ul></li><li><p>解决方案：</p><ul><li><p>使判定上移。把模块A中的判定移到模块M中；</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/4953208d6e2d01f6bbe8034de5550e82.png"></li></ul></li><li><p>受判定影响的模块下移。把模块G移到模块A下面，作为他的下级模块。</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/93b74b10dfb130df5e2e385c7a7cca99.png"></li></ul></li></ul></li></ul><h3 id="5-力争降低模块接口的复杂程度"><a href="#5-力争降低模块接口的复杂程度" class="headerlink" title="5. 力争降低模块接口的复杂程度"></a>5. 力争降低模块接口的复杂程度</h3><ul><li>模块接口复杂是软件发生错误的一个主要原因。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。</li></ul><h3 id="6-设计单入口单出口的模块"><a href="#6-设计单入口单出口的模块" class="headerlink" title="6. 设计单入口单出口的模块"></a>6. 设计单入口单出口的模块</h3><ul><li>这条启发式规则警告软件工程师不要使模块间出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。</li></ul><h3 id="7-模块功能应该可以预测"><a href="#7-模块功能应该可以预测" class="headerlink" title="7. 模块功能应该可以预测"></a>7. 模块功能应该可以预测</h3><ul><li>模块的功能应该能够预测，但也要防止模块功能过分局限。</li><li>功能可预测：如果一个模块可以当做一个黑盒子，只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。</li></ul><h3 id="8-组装软件要根据设计的约束和移植的需要"><a href="#8-组装软件要根据设计的约束和移植的需要" class="headerlink" title="8.组装软件要根据设计的约束和移植的需要"></a>8.组装软件要根据设计的约束和移植的需要</h3><h2 id="5-4描绘软件结构的图形工具"><a href="#5-4描绘软件结构的图形工具" class="headerlink" title="5.4描绘软件结构的图形工具"></a>5.4描绘软件结构的图形工具</h2><h3 id="1-层次图"><a href="#1-层次图" class="headerlink" title="1.层次图"></a>1.层次图</h3><ul><li><p>层次图用来描绘软件的层次结构。很适于在自顶向下设计软件的过程中使用。</p></li><li><p>层次图中的每个方框代表一个模块，方框间的连线表示调用关系，不同于层次方框图那样表示组成关系。</p></li><li><p>层次图和层次方框图的区别：</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/5538686b5bc943247c54f088d6a4dbbc.png"></li></ul></li><li><p>例：</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/77e65323f78594c3d6bb1e86fee21784.png"></li></ul></li></ul><h3 id="2-HIPO图"><a href="#2-HIPO图" class="headerlink" title="2.HIPO图"></a>2.HIPO图</h3><ul><li>HIPO图是美国IBM公司发明的“层次图+输入/处理/输出图”的英文缩写。</li><li>为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/b89d912fada504dff54ec25eea858387.png"></li></ul><h3 id="3-结构图"><a href="#3-结构图" class="headerlink" title="3.结构图"></a>3.结构图</h3><ul><li><p>结构图描述了程序的模块结构，表示了一个系统的层次分解关系，反映了块间联系和块内联系等特征及控制信息的传递关系。</p></li><li><p>基本图形符号：</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/c264da28bfcd6b94b515e7c11254eb57.png"></li></ul></li><li><p>选择调用：判定为真时调用A，为假时调用B。</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/7393138ab4cb62b7e723ae9f005dcea9.png"></li></ul></li><li><p>循环调用：模块M循环调用模块A、B、C。</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/c8e53e1fdcc2d7c69c2f0287c8c397fc.png"></li></ul></li><li><p>例子</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/44a3d0947fdc8eb0f3cb6ab71791ff6a.png"></li></ul></li><li><p>注意：</p><ul><li>层次图和结构图并不严格表示模块的调用次序，多数人习惯按调用次序从左到右画模块；</li><li>层次图和结构图并不指明何时调用下层模块；</li><li>层次图和结构图只表明一个模块调用那些模块，没有表示模块内还有没有其他成分；</li><li>通常用层次图作为描绘软件结构的文档；</li><li>由层次图导出结构图的过程，可以作为检查设计正确性和评价模块独立性的好方法。</li></ul></li></ul><h2 id="5-5面向数据流的设计方法（SD方法）"><a href="#5-5面向数据流的设计方法（SD方法）" class="headerlink" title="5.5面向数据流的设计方法（SD方法）"></a>5.5面向数据流的设计方法（SD方法）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>面向数据流的设计方法把信息流映射成软件结构，信息流的类型决定了映射的方法。</p></li><li><p>变换流</p><ul><li>信息沿输入通路进入系统，同时由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。</li><li>变换型结构的数据流图基本上呈线性形状</li><li>明显地分为输入、变换（或加工）和输出三部分</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/edc698725d186c764731f3103838ef50.png"></li></ul></li><li><p>事务流</p><ul><li><p>系统的数据流图呈辐射状</p></li><li><p>数据沿输入通路到达一个处理T，T根据输入数据的类型，在若干个动作序列中选出一个来执行。处理T称为事务中心，它完成下述任务：</p><ul><li>接收输入数据；</li><li>分析每个事务以确定它的类型；</li><li>根据事务类型选取一条活动通路。</li></ul></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/77f0c879dbf7cb9b363e1afd03ed0905.png"></p></li></ul></li></ul><h3 id="变换分析"><a href="#变换分析" class="headerlink" title="变换分析"></a>变换分析</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/05fa843f556433f25aef387a30735859.png"></li><li>第1步 复查基本系统模型</li><li>第2步 复查并精化数据流图</li><li>第3步 确定数据流的类型</li><li>第4步 确定输入流和输出流边界，从而孤立出变换中心</li><li>第5步 把数据流图映射成系统模块结构，即设计系统的上层模块结构</li><li>第6步  基于数据流图逐步分解高层模块结构，设计出下层模块</li><li>第7步  根据模块独立性原理，精化模块结构</li><li>第8步  描述模块接口信息，给出进出模块的数据信息</li></ul><h3 id="事务分析"><a href="#事务分析" class="headerlink" title="事务分析"></a>事务分析</h3><ul><li><p>虽然在任何情况下都可以使用变换分析方法设计软件结构，但是在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。</p></li><li><p>事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同：</p><ul><li>由事务流映射成的软件结构包括一个接收分支和一个发送分支；</li><li>映射出接收分支结构的方法和变换分析映射出输入结构的方法很相像，即从事务中心的边界开始，把沿着接收流通路的处理映射成模块；</li><li>发送分支的结构包含一个调度模块，它控制下层的所有活动模块；然后把数据流图中的每个活动流通路映射成与它的流特征相对应的结构。 </li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/3fb92a6a33043b28752c52efc720414e.png"></li></ul></li></ul><h3 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h3><ul><li>(1) 在不考虑时间因素的前提下开发并精化软件结构</li><li>(2) 在详细设计阶段选出最耗费时间的那些模块，仔细地设计它们的处理过程，以求提高效率</li><li>(3) 使用高级程序设计语言编写程序</li><li>(4) 在软件中孤立出那些大量占用处理机资源的模块</li><li>(5) 必要时重新设计或用依赖于机器的语言重写上述大量占用资源的模块的代码，以求提高效率</li><li>一句格言：“先使它能工作，然后再使它快起来。”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 期中复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第三章</title>
      <link href="2020/11/15/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>2020/11/15/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="3需求分析"><a href="#3需求分析" class="headerlink" title="3需求分析"></a>3需求分析</h1><h2 id="3-1需求分析的任务"><a href="#3-1需求分析的任务" class="headerlink" title="3.1需求分析的任务"></a>3.1需求分析的任务</h2><h3 id="3-1-1确定对系统的综合要求"><a href="#3-1-1确定对系统的综合要求" class="headerlink" title="3.1.1确定对系统的综合要求"></a>3.1.1确定对系统的综合要求</h3><ul><li><p>1.确定系统的功能要求</p><ul><li>提出系统必须完成的全部所有功能</li></ul></li><li><p>2.确定系统的性能要求</p><ul><li>性能需求指定系统必须满足的定时约束或容量约束</li><li>（1）系统的响应时间</li><li>（2）系统需要的存储容量</li><li>（3）后援存储器容量、系统重新启动</li><li>（4）系统的安全性和可靠性</li></ul></li><li><p>3.确定系统的运行要求</p><ul><li>（1）支持系统运行的软件环境</li><li>（2）工具软件和系统软件</li><li>（3）支持系统运行的硬件环境</li><li>（4）出错处理、通信接口、约束</li></ul></li><li><p>4.确定系统的扩充要求</p></li></ul><h3 id="3-1-2分析系统的数据要求"><a href="#3-1-2分析系统的数据要求" class="headerlink" title="3.1.2分析系统的数据要求"></a>3.1.2分析系统的数据要求</h3><ul><li>建立数据模型：数据字典、层次方框图、Warnier图 。</li></ul><h3 id="3-1-3导出系统的逻辑模型"><a href="#3-1-3导出系统的逻辑模型" class="headerlink" title="3.1.3导出系统的逻辑模型"></a>3.1.3导出系统的逻辑模型</h3><ul><li>用数据流图、实体一联系图、状态转换图、数据字典和主要的处理算法导出系统的详细的逻辑模型。</li></ul><h3 id="需求分析的过程"><a href="#需求分析的过程" class="headerlink" title="需求分析的过程"></a>需求分析的过程</h3><ul><li><p>（1）调查研究</p><ul><li>目的：通过各种途径获取用户需求信息产生《用户需求说明书 》</li><li>角色与职责：需求分析员调查、分析用户的需求，客户与最终用户提供必要需求信息</li></ul></li><li><p>（2）分析与综合</p><ul><li>从信息流和信息结构出发，逐步细化所有的软件功能，找出系统各元素之间的联系、接口特性和设计上的约束，分析它们是否满足功能要求。</li></ul></li><li><p>（3）书写需求分析文档</p><ul><li>软件需求说明书</li><li>数据要求说明书</li><li>初步的用户手册</li><li>修改、完善与确定软件开发实施计划</li></ul></li><li><p>（4）需求分析的评审</p><ul><li>系统定义的目标是否与用户的要求一致</li><li>系统需求分析阶段提供的文档资料是否齐全</li><li>文档中的所有描述是否完整、清晰、准确反应用户要求</li><li>与所有其它系统成分的重要接口是否都已经描述</li></ul></li></ul><h3 id="3-1-4修正系统开发计划"><a href="#3-1-4修正系统开发计划" class="headerlink" title="3.1.4修正系统开发计划"></a>3.1.4修正系统开发计划</h3><ul><li>根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。</li></ul><h2 id="3-2与用户沟通获取需求的方法"><a href="#3-2与用户沟通获取需求的方法" class="headerlink" title="3.2与用户沟通获取需求的方法"></a>3.2与用户沟通获取需求的方法</h2><h3 id="3-2-1需求获取"><a href="#3-2-1需求获取" class="headerlink" title="3.2.1需求获取"></a>3.2.1需求获取</h3><ul><li><p>需求获取是在问题及其最终解决方案之间架设桥梁的第一步。</p></li><li><p>需求获取的目的是清楚地理解所要解决的问题，完整地获得用户的需求。</p></li><li><p>获取需求的一个必不可少的结果是对项目中描述的客户需求的普遍理解。一旦理解了需求，分析者、开发者和客户就能探索出描述这些需求的多种解决方案。</p></li><li><p>需求获取活动</p><ul><li><p>（1）发现和分析问题  发现问题症结，并分析问题的原因/结果关系。</p></li><li><p>（2）获取需求  根据对问题的理解定义需求。</p><ul><li>a.使用调查研究方法收集信息；</li><li>b.遵循需求获取框架，按照三个成分观察：即数据、过程和接口。</li></ul></li><li><p>（3）需求归档  以草稿形式归档调查结果。形式有用例、决策表、需求表等</p></li></ul></li></ul><h3 id="3-2-2访谈"><a href="#3-2-2访谈" class="headerlink" title="3.2.2访谈"></a>3.2.2访谈</h3><ul><li><p>非正式访谈— 分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法。</p></li><li><p>正式访谈将根据一些事先准备好的议题全面展开讨论，得出结论性的意见。</p></li><li><p>当需要调查大量人员的意见时，向被调查人分发调查表是一个十分有效的做法。</p></li><li><p>在访问用户的过程中使用情景分析技术往往非常有效</p></li><li><p>情景分析技术的用处</p><ul><li>(1) 它能在某种程度上演示目标系统的行为，从而便于用户理解，而且还可能进一步揭示出一些分析员目前还不知道的需求。</li><li>(2) 由于情景分析较易为用户所理解，使用这种技术能保证用户在需求分析过程中始终扮演一个积极主动的角色。需求分析的目标是获知用户的真实需求，而这一信息的惟一来源是用户，因此，让用户起积极主动的作用对需求分析工作获得成功是至关重要的。</li></ul></li></ul><h3 id="3-2-3面向数据流自顶向下求精"><a href="#3-2-3面向数据流自顶向下求精" class="headerlink" title="3.2.3面向数据流自顶向下求精"></a>3.2.3面向数据流自顶向下求精</h3><ul><li><p>通过可行性研究已经得出了目标系统的高层数据流图，需求分析的目标之一就是把数据流和数据存储定义到元素级。</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/c21b31210a2aeb97065e218ce3b1649b.png"></li></ul></li><li><p>结构化分析方法（SA）</p><ul><li>“数据流图”描述系统的分解，即描述系统由哪些部分组成，每个部分之间有什么样的联系等；</li><li>“数据字典”描述系统中的每一个数据；</li><li>“小说明”详细描述系统中的每一个加工；</li><li>“补充材料”是根据需要对系统的补充。</li><li>以上就可以明确而完整地描述一个系统的功能</li></ul></li></ul><h3 id="3-3-4快速建立软件模型"><a href="#3-3-4快速建立软件模型" class="headerlink" title="3.3.4快速建立软件模型"></a>3.3.4快速建立软件模型</h3><ul><li><p>基本思想</p><ul><li>在很短的时间内建立起一个只包含基本数据库和一些基本功能的原型给用户使用，然后根据用户意见对原型进行修改，直到满意为止。</li></ul></li><li><p>快速构建和修改原型，通常使用的3种方法和工具</p><ul><li><p>(1)第四代技术</p><ul><li>包括众多数据库查询和报表语言、程序和应用系统生成器以及其他非常高级的非过程语言。能快速生成可执行的代码。 </li></ul></li><li><p>(2)可重用的软件构件</p><ul><li>使用一组已有的软件构件（也称为组件）来装配（而不是从头构造）原型。 </li></ul></li><li><p>(3)形式化规格说明和原型环境</p><ul><li>在交互式环境下，用自动工具把基于形式语言的规格说明翻译成可执行的程序代码。</li></ul></li></ul></li></ul><h2 id="3-3分析建模与规格说明"><a href="#3-3分析建模与规格说明" class="headerlink" title="3.3分析建模与规格说明"></a>3.3分析建模与规格说明</h2><h3 id="什么是模型？"><a href="#什么是模型？" class="headerlink" title="什么是模型？"></a>什么是模型？</h3><ul><li>为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。</li><li>模型通常由一组图形符号和组织这些符号的规则组成。</li></ul><h3 id="模型的作用"><a href="#模型的作用" class="headerlink" title="模型的作用"></a>模型的作用</h3><ul><li>在建模过程中了解系统</li><li>通过抽象降低复杂性</li><li>有助于回忆所有的细节</li><li>有助于开发小组间的交流</li><li>有助于与用户的交流</li><li>为系统的维护提供文档</li></ul><h3 id="结构化分析（-Structured-Analysis-SA-）"><a href="#结构化分析（-Structured-Analysis-SA-）" class="headerlink" title="结构化分析（ Structured Analysis , SA ）"></a>结构化分析（ Structured Analysis , SA ）</h3><ul><li><p>是面向数据流进行分析的方法，主要建立以下几种模型：</p><ul><li>实体关系图(Entity-Relationship Diagram,E-R图)来创建数据模型，描述系统中所有重要的数据对象；</li><li>数据流图（Data Flow Diagram,DFD） ：用来创建功能模型，描述了信息流和数据转换。</li><li>状态转换图 （State-Transition Diagram,STD）用来创建行为模型，描述系统状态如何响应外部事件，而进行转换。</li></ul></li></ul><h3 id="面向对象分析方法建立的模型"><a href="#面向对象分析方法建立的模型" class="headerlink" title="面向对象分析方法建立的模型"></a>面向对象分析方法建立的模型</h3><ul><li>对象模型(Object model)：定义实体，描述系统的静态结构，定义“对谁做”</li><li>动态模型(Dynamic model):描述对象之间的交互过程，规定“何时做”</li><li>功能模型 (Functional model) ：描述内部数据的处理，指明系统应“做什么”</li></ul><h2 id="3-4实体-联系图"><a href="#3-4实体-联系图" class="headerlink" title="3.4实体-联系图"></a>3.4实体-联系图</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><ul><li>ER图 —- 是用来建立数据模型的工具。</li><li>数据模型 —- 是一种面向问题的数据模型，是按照用户的观点对数据建立的模型。它描述了从用户角度看到的数据，反映了用户的现实环境，而且与在软件系统中的实现方法无关。</li><li>数据模型中包含3种相互关联的信息：数据对象（实体）、数据对象的属性及数据对象彼此间相互连接的关系。</li></ul><h3 id="1-数据对象-实体"><a href="#1-数据对象-实体" class="headerlink" title="1.数据对象(实体)"></a>1.数据对象(实体)</h3><ul><li>数据对象:是信息世界中描述客观事物的概念。</li><li>可以由一组属性来定义的实体都可以被认为是数据对象。</li><li>如：外部实体、事物、行为、事件、角色、单位、地点或结构等。</li><li>数据对象彼此间是有关联的。</li></ul><h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h3><ul><li>属性定义了数据对象的性质。</li><li>必须把一个或多个属性定义为“标识符”，也就是说，当我们希望找到数据对象的一个实例时，用标识符属性作为“关键字”(通常简称为“键”)。</li><li>应该根据对所要解决的问题的理解，来确定特定数据对象的一组合适的属性。</li><li>如：学生具有学号、姓名、性别、年龄、专业等属性；</li><li>课程具有课程号、课程名、学分、学时数等属性；</li><li>教师具有职工号、姓名、年龄、职称等属性。</li></ul><h3 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h3><ul><li>a.  一对一联系(1∶1)</li><li>b.  一对多联系(1∶N)</li><li>c. 多对多联系(M∶N)</li></ul><h3 id="实体-联系图的符号"><a href="#实体-联系图的符号" class="headerlink" title="实体-联系图的符号"></a>实体-联系图的符号</h3><ul><li>ER图中包含了实体(即数据对象)、关系和属性等3种基本成分。</li><li>通常用矩形框代表实体；</li><li>用连接相关实体的菱形框表示关系；</li><li>用椭圆形表示实体(或关系)的属性；</li><li>并用直线把实体(或关系)与其属性连接起来。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/31fa1ba0abb172e73fe030e5433bd4fa.png"></li></ul><h2 id="3-5数据规范化"><a href="#3-5数据规范化" class="headerlink" title="3.5数据规范化"></a>3.5数据规范化</h2><h3 id="数据规范化的目的"><a href="#数据规范化的目的" class="headerlink" title="数据规范化的目的"></a>数据规范化的目的</h3><ul><li>（1）消除数据冗余，即消除表格中数据的重复；</li><li>（2）消除多义性，使关系中的属性含义清楚、单一；</li><li>（3）使关系的“概念”单一化，让每个数据项只是一个简单的数或字符串，而不是一个组项或重复组；</li><li>（4）方便操作。使数据的插入、删除与修改操作可行并方便；</li><li>（5）使关系模式更灵活，易于实现接近自然语言的查询方式。</li></ul><h3 id="3种范式"><a href="#3种范式" class="headerlink" title="3种范式"></a>3种范式</h3><ul><li>第一范式：每个属性值都必须是原子值，即仅仅是一个简单值而不含内部结构。</li><li>第二范式：满足第一范式条件，而且每个非关键字属性都由整个关键字决定(而不是由关键字的一部分来决定)。</li><li>第三范式：符合第二范式的条件，每个非关键字属性都仅由关键字决定，而且一个非关键字属性不能仅仅是对另一个非关键字属性的进一步描述(即一个非关键字属性值不依赖于另一个非关键字属性值)。</li></ul><h2 id="3-6状态转换图"><a href="#3-6状态转换图" class="headerlink" title="3.6状态转换图"></a>3.6状态转换图</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。此外，状态图还指明了作为特定事件的结果系统将做哪些动作(例如，处理数据)。</li></ul><h3 id="（1）状态"><a href="#（1）状态" class="headerlink" title="（1）状态"></a>（1）状态</h3><ul><li>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。系统对事件的响应，既可以是做一个(或一系列)动作，也可以是仅仅改变系统本身的状态，还可以是既改变状态又做动作。</li></ul><h3 id="（2）事件"><a href="#（2）事件" class="headerlink" title="（2）事件"></a>（2）事件</h3><ul><li>事件是在某个特定时刻发生的事情，它是对引起系统做动作或(和)从一个状态转换到另一个状态的外界事件的抽象。</li><li>例如，内部时钟表明某个规定的时间段已经过去，用户移动或点击鼠标等都是事件。</li><li>简而言之，事件就是引起系统做动作或(和)转换状态的控制信息。</li></ul><h3 id="（3）符号"><a href="#（3）符号" class="headerlink" title="（3）符号"></a>（3）符号</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/4b7c134dddd7d0d8018b27da370f4292.png"></li></ul><h3 id="（4）例子（见书本）"><a href="#（4）例子（见书本）" class="headerlink" title="（4）例子（见书本）"></a>（4）例子（见书本）</h3><h2 id="3-7其他图形工具"><a href="#3-7其他图形工具" class="headerlink" title="3.7其他图形工具"></a>3.7其他图形工具</h2><h3 id="3-7-1-层次方框图"><a href="#3-7-1-层次方框图" class="headerlink" title="3.7.1  层次方框图"></a>3.7.1  层次方框图</h3><ul><li>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。</li><li>树形结构的顶层是一个单独的矩形框，它代表完整的数据结构，下面的各层矩形框代表这个数据的子集，最底层的各个框代表组成这个数据的实际数据元素(不能再分割的元素)。</li><li>随着结构的精细化，层次方框图对数据结构也描绘得越来越详细，这种模式非常适合于需求分析阶段的需要。系统分析员从对顶层信息的分类开始，沿图中每条路径反复细化，直到确定了数据结构的全部细节时为止。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/ca1550bdfed0ff95e7a00a50a4a27a6f.png"></li></ul><h3 id="3-7-2-Warnier图"><a href="#3-7-2-Warnier图" class="headerlink" title="3.7.2  Warnier图"></a>3.7.2  Warnier图</h3><ul><li>法国计算机科学家Warnier提出了表示信息层次结构的另外一种图形工具。</li><li>Warnier图也用树形结构描绘信息，但是这种图形工具比层次方框图提供了更丰富的描绘手段。</li><li>用Warnier图可以表明信息的逻辑组织。它可以指出一类信息或一个信息元素是重复出现的，也可以表示特定信息在某一类信息中是有条件地出现的。</li><li>重复和条件约束是说明软件处理过程的基础，所以很容易把Warnier图转变成软件设计的工具。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/ece2d4657c23106a44ee04ee61ce9170.png"></li><li>图中表示一种软件产品要么是系统软件要么是应用软件。系统软件中有P1种操作系统，P2种编译程序，此外还有软件工具。软件工具是系统软件的一种，它又可以进一步细分为编辑程序、测试驱动程序和设计辅助工具，图中标出了每种软件工具的数量。</li></ul><h3 id="3-7-2-IPO图"><a href="#3-7-2-IPO图" class="headerlink" title="3.7.2  IPO图"></a>3.7.2  IPO图</h3><ul><li>IPO图是输入、处理、输出图的简称，它是美国IBM公司发展完善起来的一种图形工具</li><li>描述输入数据、处理数据和输出数据</li><li>在需求分析阶段使用IPO图简略的描述系统的主要算法</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/8a5d9a75f839f8e9b47fbbbe9d55e86b.png"></li><li>左边的框中列出有关的输入数据。</li><li>中间的框内列出主要的处理，处理框中列出处理的次序暗示了执行的顺序，但是用这些基本符号还不足以精确描述执行处理的详细情况。</li><li>在右边的框内列出产生的输出数据。</li><li>在IPO图中还用类似向量符号的粗大箭头清楚地指出数据通信的情况。</li></ul><h3 id="3-7-3-改进的IPO图-也称为IPO表"><a href="#3-7-3-改进的IPO图-也称为IPO表" class="headerlink" title="3.7.3   改进的IPO图(也称为IPO表)"></a>3.7.3   改进的IPO图(也称为IPO表)</h3><ul><li>在需求分析阶段可以使用IPO表简略地描述系统的主要算法(即数据流图中各个处理的基本算法)。</li><li>需求分析阶段，IPO表中的许多附加信息暂时还不具备，但在设计阶段可以进一步补充修正这些图，作为设计阶段的文档。</li><li>这正是在需求分析阶段用IPO表作为描述算法的工具的重要优点。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/8a9843255e53acda262a4d4c129ca72c.png"></li><li>在需求分析阶段可以使用IPO表简略地描述系统的主要算法(即数据流图中各个处理的基本算法)。</li><li>需求分析阶段，IPO表中的许多附加信息暂时还不具备，但在设计阶段可以进一步补充修正这些图，作为设计阶段的文档。</li><li>这正是在需求分析阶段用IPO表作为描述算法的工具的重要优点</li></ul><h2 id="3-8验证软件需求"><a href="#3-8验证软件需求" class="headerlink" title="3.8验证软件需求"></a>3.8验证软件需求</h2><h3 id="一、验证软件需求的正确性"><a href="#一、验证软件需求的正确性" class="headerlink" title="一、验证软件需求的正确性"></a>一、验证软件需求的正确性</h3><ul><li>(1) 一致性   所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。</li><li>(2) 完整性  需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。</li><li>(3) 现实性  指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。</li><li>(4) 有效性  必须证明需求是正确有效的，确实能解决用户面对的问题。</li></ul><h3 id="二、验证软件需求的方法"><a href="#二、验证软件需求的方法" class="headerlink" title="二、验证软件需求的方法"></a>二、验证软件需求的方法</h3><ul><li><p>1、验证需求的一致性</p><ul><li><pre><code>人工技术：需求分析的结果是用自然语言书写</code></pre></li><li><pre><code>软件工具:  软件需求规格说明书是用形式化的需求陈述语言书写</code></pre></li></ul></li><li><p>2、验证需求的现实性</p><ul><li><pre><code>分析员应该参照以往开发类似系统的经验，分析用现有的软、硬件技术实现目标系统的可能性。必要的时候应该采用仿真或性能模拟技术，辅助分析软件需求规格说明书的现实性。</code></pre></li></ul></li><li><p>3、验证需求的完整性和有效性</p><ul><li><pre><code>使用原型系统，而不去开发实际系统，这样做可以节约成本和时间，其目的是显示目标系统的主要功能，而不是性能。</code></pre></li></ul></li></ul><h3 id="三、用于需求分析的软件工具"><a href="#三、用于需求分析的软件工具" class="headerlink" title="三、用于需求分析的软件工具"></a>三、用于需求分析的软件工具</h3><ul><li>RSL（需求陈述语言）</li><li>PSL/PSA （问题陈述语言/问题陈述分析程序）</li></ul><h2 id="3-9需求分析步骤总结"><a href="#3-9需求分析步骤总结" class="headerlink" title="3.9需求分析步骤总结"></a>3.9需求分析步骤总结</h2><ul><li><p>⑴ 问题描述</p></li><li><p>⑵ 画分层的数据流图</p></li><li><p>⑶ 决定哪些部分需要计算机化和怎样计算机化</p></li><li><p>⑷ 数据细节描述</p></li><li><p>⑸ 定义处理逻辑</p></li><li><p>⑹ 定义物理资源</p></li><li><p>⑺ 确定输入/输出规格说明，确定有关数值</p></li><li><p>⑻ 确定硬件需求</p></li><li><p>⑼ 根据结构化分析模型，建立系统规格说明文档</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 期中复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第二章</title>
      <link href="2020/11/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>2020/11/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="2-可行性研究"><a href="#2-可行性研究" class="headerlink" title="2.可行性研究"></a>2.可行性研究</h1><h2 id="2-1问题定义"><a href="#2-1问题定义" class="headerlink" title="2.1问题定义"></a>2.1问题定义</h2><h3 id="1-问题定义的内容"><a href="#1-问题定义的内容" class="headerlink" title="1.问题定义的内容"></a>1.问题定义的内容</h3><ul><li>（1）问题的背景，弄清楚待开发系统现在处于什么状态，为什么要开发它，是否具备开发条件等问题。</li><li>（2）提出开发系统的问题要求以及总体要求。</li><li>（3）明确问题的性质、类型和范围。</li><li>（4）明确待开发系统要实现的目标、功能和规模。</li><li>（5）提出开发的条件要求和环境要求。</li></ul><h3 id="2-问题定义的方法"><a href="#2-问题定义的方法" class="headerlink" title="2.问题定义的方法"></a>2.问题定义的方法</h3><ul><li>首先，系统分析员要针对用户的要求做详细的调查研究，认真听取用户对问题的介绍；阅读与问题有关的资料，必要时还要深入现场，亲自操作；调查开发系统的背景;了解用户对开发的要求。</li><li>其次，是与用户反复讨论，以使问题进一步确定化。经过用户和系统分析员双方充分协商，确定问题定义的内容。</li><li>最后，写出双方均认可的问题定义报告。</li></ul><h2 id="2-2可行性研究的目的和任务"><a href="#2-2可行性研究的目的和任务" class="headerlink" title="2.2可行性研究的目的和任务"></a>2.2可行性研究的目的和任务</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h3><ul><li>明确问题是否能够解决</li><li>明确问题是否值得去解决</li></ul><h3 id="2-实质"><a href="#2-实质" class="headerlink" title="2.实质"></a>2.实质</h3><ul><li>可行性研究的实质是在高层次上做一次大大简化了的需求分析和设计。是在较高层次上以较抽象的方式进行的系统分析和设计的过程。</li></ul><h3 id="可行性研究应着重考虑的五个方面："><a href="#可行性研究应着重考虑的五个方面：" class="headerlink" title="可行性研究应着重考虑的五个方面："></a>可行性研究应着重考虑的五个方面：</h3><ul><li><p>（1）技术可行性</p><ul><li>主要包括:在给出的限制范围内，能否设计出系统，并实现必要的功能和性能;开发人员、硬件和软件是否存在问题;系统所用到的相关技术是否支持。</li></ul></li><li><p>（2）经济可行性</p><ul><li>经济可行性问题包含两方面：一方面是经济实力；另一方面是经济效益。分析经济可行性研究的内容是要进行开发成本的估算，了解项目成功取得效益的评估，确定要开发的项目是否值得投资开发。</li></ul></li><li><p>（3）运行可行性</p><ul><li>如果新系统建立在原来已担负其他任务的原系统上，就不能要求它在实时在线状态下运行，以免与原有的任务相矛盾。</li></ul></li><li><p>（4）操作可行性</p><ul><li>① 软件能否被有效的使用；</li><li>②开发过程中能否得到用户方的必要支持；</li><li>③软件使用所带来的影响用户方能否接受。</li></ul></li><li><p>（5）法律可行性</p></li></ul><blockquote><p>可行性研究最根本的任务是对以后的行动方向提出建议。如果可行性研究的结果是问题没有可行的解，那么系统分析员应该建议停止这项工程的开发;如果可行性研究的结果是问题值得去解决，那么系统分析员应该推荐一个较好的解决方案，并且为工程制定一个初步的开发计划。</p></blockquote><h2 id="2-3可行性研究过程"><a href="#2-3可行性研究过程" class="headerlink" title="2.3可行性研究过程"></a>2.3可行性研究过程</h2><h3 id="1-可行性研究工作流程"><a href="#1-可行性研究工作流程" class="headerlink" title="1.可行性研究工作流程"></a>1.可行性研究工作流程</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/2e9f836b78e6d90a6684bb66178ca498.png"></li></ul><h3 id="2-可行性研究的方法和步骤"><a href="#2-可行性研究的方法和步骤" class="headerlink" title="2. 可行性研究的方法和步骤"></a>2. 可行性研究的方法和步骤</h3><ul><li><p>（1）复查系统规模和目标</p><ul><li>分析员访问关键人员，仔细阅读和分析有关的材料，对项目的规模和目标进行定义和确认，描述项目的一切限制和约束，以确保分析员提交的报告书确实是用户要求解决的。</li></ul></li><li><p>（2）研究目前正在使用的系统</p><ul><li>现有系统的基本功能是新系统所必须具备的；</li><li>现有系统存在的缺点，新系统必须加以改进；</li><li>现有系统所不具备的功能，又是用户必须的，则新系统一定要预以增加；</li><li>现有系统所需要的费用是新系统的一个重要的投资依据。如果新系统不能增加收入或减少使用费用，那么从经济角度看新系统就不如旧系统。</li></ul></li><li><p>（3）导出新系统的高层逻辑模型</p><ul><li><p>从现有的物理系统出发，导出现有物理系统的逻辑模型；</p></li><li><p>再以现有物理系统的逻辑模型为基础，设计出新系统的高层逻辑模型；</p></li><li><p>最后根据高层逻辑模型建造新的物理系统。</p></li><li><p>3类模型</p><ul><li><p>概念模型</p><ul><li>概念模型就是在了解了用户的需求，用户的业务领域工作情况以后，经过分析和总结，提炼出来的用以描述用户业务需求的一些概念的东西。如销售业务中的“客户”和“定单”，还有就是“商品”，“业务员”。一个用例描述就是：“业务员”与“客户”就购买“商品”之事签定下“定单”。</li></ul></li><li><p>逻辑模型</p><ul><li>逻辑模型就是要将概念模型具体化。要实现概念模型所描述的东西，需要哪些具体的功能和处理哪些具体的信息。这就到了需求分析的细化阶段。仍以销售业务为例：“客户”信息基本上要包括：单位名称，联系人，联系电话，地址等属性；“商品”信息基本上要包括：名称，类型，规 格，单价等属性；“定单”信息基本上要包括：日期和时间属性。并且“定单”要与“客户”，“业务员”和“商品”明细关联。  </li></ul></li><li><p>物理模型</p><ul><li>物理模型就是针对上述逻辑模型所说的内容，在具体的物理介质上实现出来。如：数据库使用SQL Server 2000，这样就可以编写具体的SQL脚本在数据库服务器上将数据库建立起来。其中包括业务员信息表，客户信息表，商品信息表，定单表。客户端使用VS开发工具，那么在工作站上用VS建立起功能菜单，包括：业务员信息维护，客户信息维护，商品信息维护，建立销售定单等功能，并用工具将每一个功能编码实现。</li></ul></li></ul></li></ul></li><li><p>（4）进一步定义问题 </p><ul><li>定义系统目标 —&gt; 复查系统目标和规模 —&gt; 研究现有系统 —&gt; 设计新系统 —&gt; 再定义系统目标。</li></ul></li><li><p>（5）导出和评价供选择的方案 </p><ul><li> 从技术角度排除那些不现实的方案；</li><li> 从操作角度去掉那些操作方式或操作过程是用户不能接受的方案；</li><li> 从经济角度估算每个可能系统的成本/效益。</li></ul></li><li><p>（6）推荐方案和行动方针 </p><ul><li>本项目的开发价值；</li><li>推荐这个方案的理由；</li><li>制订实现项目的进度表。</li></ul></li><li><p>（7）决策 </p><ul><li>使用部门的负责人根据经济实力及分析员在可行性研究阶段对开发此项工程成本/效益分析情况的分析结论，决定是否继续这项开发工程。</li></ul></li><li><p>（8）草拟开发计划</p><ul><li>工程的进度；</li><li>人才资源（系统分析员、程序员）的需求及使用；</li><li>设备资源的需求及使用（软、硬件工具）、估算生存周期每个阶段的成本；   </li><li>给出下一阶段（需求分析）的详细进度表和成本估计。</li></ul></li><li><p>（9）书写文档提交审查  </p></li></ul><h2 id="2-4系统流程图"><a href="#2-4系统流程图" class="headerlink" title="2.4系统流程图"></a>2.4系统流程图</h2><h3 id="1基本内容"><a href="#1基本内容" class="headerlink" title="1基本内容"></a>1基本内容</h3><ul><li>（1）用图形符号以黑盒子形式描述系统内的每一个成分（例如:程序、文件、数据库、表格、硬件设备、人工过程等）。</li><li>（2）用“→”表示信息在系统各个成分之间的流动情况，不要误认为“　”表示信息的加工和控制过程。因此尽管系统流程图的某些符号和程序流程图的符号形式相同，但是它却是物理数据流图而不是程序流程图。</li></ul><h3 id="2符号"><a href="#2符号" class="headerlink" title="2符号"></a>2符号</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/11d455c205975352c3603f0cc66b9fc5.png"></li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/f7f5fcbdf42b26d2930a1a10891714bb.png"></li></ul><h3 id="3例子（见书本）"><a href="#3例子（见书本）" class="headerlink" title="3例子（见书本）"></a>3例子（见书本）</h3><h3 id="4分层"><a href="#4分层" class="headerlink" title="4分层"></a>4分层</h3><ul><li>面对复杂的系统时，一个比较好的方法是分层次地描绘这个系统。首先用一张高层次的系统流程图描绘系统总体概貌，表明系统的关键功能。然后分别把每个关键功能扩展到适当的详细程度，画在单独的一页纸上。这种分层次的描绘方法便于阅读者按从抽象到具体的过程逐步深入地了解一个复杂的系统。</li></ul><h2 id="2-5数据流图"><a href="#2-5数据流图" class="headerlink" title="2.5数据流图"></a>2.5数据流图</h2><h3 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="1.基本内容"></a>1.基本内容</h3><ul><li><p>数据流图（DFD）是描述数据处理过程的工具。它从数据传递和加工的角度，以图形的方式描述数据流从输入到输出的传输变换过程。</p><ul><li>一种图形化技术，一种描述“分解”的图示工具</li><li>表示信息和数据从输入到输出所经受的变换</li><li>描述数据在系统中流动和被处理的逻辑过程</li><li>没有任何具体的物理部件</li></ul></li></ul><h3 id="2-符号"><a href="#2-符号" class="headerlink" title="2.符号"></a>2.符号</h3><ul><li>（1）“→”表示数据和数据流。箭头表示数据的流动方向。数据流图中应在线旁标注数据流名。</li><li>（2）“○”表示对数据的加工，即对数据的某种操作或变换。数据流图中应在圆圈内写上加工名。</li><li>（3）“     ”表示按照某种规则生成，且长度不限的数据文件（也称数据存储）。数据流图中应在双线旁标注文件名。</li><li>（4）“□”表示数据流的源头和终端。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/e354e92a7038ff0d6e5864c85e3aef9d.png"></li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/aea8fc2409fd1510c5d2ec7a74a79423.png"></li></ul><h3 id="3-例子（见书本）"><a href="#3-例子（见书本）" class="headerlink" title="3.例子（见书本）"></a>3.例子（见书本）</h3><h3 id="4-命名"><a href="#4-命名" class="headerlink" title="4.命名"></a>4.命名</h3><ul><li><p>数据流(或数据存储)</p><ul><li>（1）名字应代表整个数据流(或数据存储)的内容，而不是仅仅反映它的某些成分。</li><li>（2） 不要使用空洞的、缺乏具体含义的名字(如“数据”、“信息”、“输入”之类)。</li><li>（3） 如果在为某个数据流(或数据存储)起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成的，应该试试重新分解，看是否能克服这个困难。</li><li>（4）两个加工之间可以有多个数据流，这些数据流之间没有任何联系。在加工之间传输的数据流必须有一个合适的名词，而在文件和加工之间传输的数据流可以不命名，因为可以从“加工”和“文件”的名字，弄清数据流的含义</li></ul></li><li><p>处理</p><ul><li>(1) 通常先为数据流命名，然后再为与之相关联的处理命名。</li><li>(2) 名字应该反映整个处理的功能，而不是它的一部分功能。  不要使用含糊不具体的动词，如“处理”、“加工”等。 </li><li>(3) 名字最好由一个具体的及物动词加上一个具体的宾语组成。</li><li>(4) 通常名字中仅包括一个动词，如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。</li><li>(5) 如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的迹象，应考虑重新分解。</li></ul></li><li><p>数据源头和终点</p><ul><li>数据源头和终点是数据的始发点和终止点，是表示系统和环境的接口。在实际问题中，它可以是人员、计算机外部设备或其他装置，不需要对它进行软件设计和实现。因此，在命名时应符合环境的真实状况.</li></ul></li></ul><h3 id="5-优点"><a href="#5-优点" class="headerlink" title="5.优点"></a>5.优点</h3><ul><li>DFD用一种直接而又直观的方法来描述数据的流动和信息系统中的操作。首先，它使用客观图像描述了用户的需求，不带有任何个人或组织的说法或观点。其次，数据流图形象真实，便于用户理解和接受，同时也便于系统分析员之间交流信息。最后，数据流图采用自顶向下分解的多层次图形具有一定的抽象性，而且数据流图不强调控制流，突出数据流，便于找到主要矛盾，省略次要细节，从而减少系统的复杂性。</li></ul><h3 id="6-缺点"><a href="#6-缺点" class="headerlink" title="6.缺点"></a>6.缺点</h3><ul><li>DFD图形符号也存在着一定的缺点。首先，数据流图对时间、界面等方面的内容无法表达。其次，DFD只能做出粗略的模型，而如果需要更精确、更详细的说明时，DFD无法做到。</li></ul><h3 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h3><ul><li>1、作为信息交流的工具分析员把他对现有系统的认识或对目标系统的设想用数据流图描绘出来，供有关人员审查确认。</li><li>2、作为分析和设计的工具</li><li>3、数据流图可以辅助物理系统的设计（图）根据不同要求，能够在数据流图上画出许多组自动化边界，每组自动化边界可能意味着一个不同的物理系统，因此可以根据系统的逻辑模型考虑系统的物理实现。</li><li>4、数据流图对详细设计也有帮助。</li></ul><h2 id="2-6数据字典"><a href="#2-6数据字典" class="headerlink" title="2.6数据字典"></a>2.6数据字典</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><ul><li>数据字典是关于数据信息的集合。数据字典定义数据流图中所有元素（包括数据流、数据流的组成、文件及其它应进入数据字典的一切数据）。</li></ul><h3 id="2-与数据流图的联系"><a href="#2-与数据流图的联系" class="headerlink" title="2.与数据流图的联系"></a>2.与数据流图的联系</h3><ul><li>数据字典中所有名字的定义就够成了一本字典与数据流图共同构成系统的逻辑模型</li></ul><h3 id="3-数据字典的内容"><a href="#3-数据字典的内容" class="headerlink" title="3. 数据字典的内容"></a>3. 数据字典的内容</h3><p>分别对DFD中元素的定义：</p><ul><li><p>  数据流</p></li><li><p>数据流分量（即数据元素）</p><ul><li>   名字、别名、描述、数据类型、长度、结构、值的范围、使用方式、控制信息、分组信息等</li></ul></li><li><p>  数据存储</p></li><li><p>  处理 （结合IPO图或PDL ） </p></li></ul><h3 id="4-定义数据的方法"><a href="#4-定义数据的方法" class="headerlink" title="4.定义数据的方法"></a>4.定义数据的方法</h3><ul><li><p>组成数据的方式</p><ul><li>1）顺序 —— 以确定次序连接两个或多个分量</li><li>2）选择 —— 从两个或多个可能的元素中选取一个</li><li>3）重复 —— 把指定的分量重复零次或多次</li><li>4）可选 —— 一个分量是可有可无的</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/3f459c830d62cce83905c0aa809bdc38.png"></li></ul></li></ul><h3 id="5-用途"><a href="#5-用途" class="headerlink" title="5. 用途"></a>5. 用途</h3><ul><li>作为分析阶段的工具</li><li>能单独处理描述每个数据元素的信息</li><li>是开发数据库的第一步（基础 关键）</li></ul><h3 id="6-数据字典的实现"><a href="#6-数据字典的实现" class="headerlink" title="6.数据字典的实现"></a>6.数据字典的实现</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/0d45fe53cf8b1bcae4770ea94502950d.png"></li></ul><h2 id="2-7成本-效益分析"><a href="#2-7成本-效益分析" class="headerlink" title="2.7成本/效益分析"></a>2.7成本/效益分析</h2><h3 id="1-成本估计："><a href="#1-成本估计：" class="headerlink" title="1.成本估计："></a>1.成本估计：</h3><ul><li><p>（1）代码行技术（LOC技术）</p><ul><li>1）确定功能：把项目功能反复分解到足够细，直到可以对为实现该功能所需要的源代码行数作出可靠的估算为止。</li><li>2）算出各子功能代码行数的平均值：首先根据经验和历史数据对每个子功能估计其程序规模的大小，即最小规模a，最大规模b和最可能的规模m，然后用下式计算该子功能的源代码行数的平均值Le:</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/2efb453bdca27476a11dbe9c6a14a320.png"></li><li>3） 确定各子功能的代码行成本和生产率：</li><li>4） 计算各子功能的成本和人力（工作量）</li><li>5）计算该项目的总代码行数、总成本和总工作量。</li></ul></li><li><p>（2）任务分解技术</p><ul><li>工程分解为若干个相对独立的任务 - 按阶段划分 - 按子系统划分</li><li>分别估计每个单独的开发任务的成本 -  每个任务的成本  =  耗费人力(人月)*人月平均工资</li><li>累加得到工程的总成本</li></ul></li><li><p>（3）自动估计成本技术</p><ul><li>采用自动估计成本的软件工具</li><li>长期搜集的大量历史数据为基础</li><li>有良好的数据库系统支持</li></ul></li></ul><h3 id="2-成本-效益分析方法"><a href="#2-成本-效益分析方法" class="headerlink" title="2.成本/效益分析方法"></a>2.成本/效益分析方法</h3><ul><li><p>基本内容</p><ul><li>估计开发成本、运行费用和新系统将带来的经济效益</li><li>运行费用取决于系统的操作费用(人员数、工作时间、损耗等)和维护费用</li><li>系统的经济效益等于因使用新系统而增加的收入加上使用新系统可以节省的运行费用。</li><li>总的效益和估计的软件寿命有关。</li></ul></li><li><p>四个重要的概念：</p><ul><li><p>货币的时间价值 </p><ul><li>比较新系统的开发成本（当前）和经济效益（未来）</li><li>用利率的形式表示货币的时间价值。</li></ul></li><li><p>纯收入</p><ul><li>在整个生命周期之内系统的累计经济效益(折合成现在值)与投资之差。</li></ul></li><li><p>投资回收期</p><ul><li>用来衡量一项开发工程的价值</li><li>是使累计的经济效益等于最初投资所需要的时间</li><li>投资回收期越短就能越快获得利润，也就越值得投资。</li><li>是一项经济指标</li></ul></li><li><p>投资回收率</p><ul><li>衡量投资效益的大小</li><li>通常和年利率相比较，衡量经济效益</li></ul></li></ul></li></ul><h2 id="2-8可行性研究报告"><a href="#2-8可行性研究报告" class="headerlink" title="2.8可行性研究报告"></a>2.8可行性研究报告</h2><ul><li><p>1）引言：说明可行性研究的目的，项目的名称、背景，本文档用到的术语和参考资料。</p></li><li><p>2）可行性研究的前提：说明待开发项目的功能、性能和基本要求，要达到的目标，各种约束条件，可行性研究的方法和决定可行性的主要因素。</p></li><li><p>3）对现行系统的分析：如果有现行系统，说明现行系统的处理流程和数据流程，系统状态，费用支出，所需专业人员的种类和数量，所需设备，存在的问题等。</p></li><li><p>4）方案选择：所选择方案的系统配置，选择方案的标准。</p></li><li><p>5）技术可行性分析：对所选择的较好的方案的风险分析、资源分析和技术分析；对子系统的技术分析。</p></li><li><p>6）经济可行性分析：说明所建议系统的成本-效益分析结果。</p></li><li><p>7）运行、操作可行性分析。</p></li><li><p>8）法律可行性分析。</p></li><li><p>9）其他可供选择方案：分别说明每一个可供选择的方   案，并应说明未被推荐的理由。</p></li><li><p>10）结论意见：说明项目是否能开发，还需要什么条件才能开发以及对项目目标有何变动等。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 期中复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第一章</title>
      <link href="2020/11/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2020/11/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-软件工程学概述"><a href="#1-软件工程学概述" class="headerlink" title="1.软件工程学概述"></a>1.软件工程学概述</h1><h2 id="1-1软件危机"><a href="#1-1软件危机" class="headerlink" title="1.1软件危机"></a>1.1软件危机</h2><h3 id="1-1-1软件危机的介绍"><a href="#1-1-1软件危机的介绍" class="headerlink" title="1.1.1软件危机的介绍"></a>1.1.1软件危机的介绍</h3><ul><li>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题</li><li>软件危机包含两方面的问题：如何开发软件，以满足对软件日益增长的需求，如何维护数量不断膨胀的已有软件。</li></ul><h3 id="1-1-2产生软件危机的原因"><a href="#1-1-2产生软件危机的原因" class="headerlink" title="1.1.2产生软件危机的原因"></a>1.1.2产生软件危机的原因</h3><ul><li><p>客观原因：由软件本身的特点决定</p><ul><li>   软件是手工劳动，是智力产品—-生产率低。</li><li>   软件是逻辑实体，出错容易，纠错困难。</li><li>   软件的复杂性使得仅靠人的智力难以驾驭。</li></ul></li><li><p>主观原因：</p><ul><li>开发方式：认为开发软件就是写程序。</li><li>组织方式：作坊式的生产方式；开发无计划、开发过程无规范、开发过程难控制。</li><li>用户方面：对软件需求描述不精确。</li><li>开发人员方面：对用户需求的理解与用户本来愿望有差异，相互之间的信息交流不及时、不准确、有误解。</li></ul></li><li><p>软件危机的表现形式</p><ul><li>（1）对软件开发成本和进度的估计常常很不准确。</li><li>（2）用户对“已完成的”软件系统不满意的现象经常发生。</li><li>（3）软件产品的质量往往靠不住。</li><li>（4）软件常常是不可维护的。</li><li>（5）软件通常没有适当的文档资料。</li><li>（6）软件成本在计算机系统总成本所占的比例逐年上升。</li><li>（7）软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势、软件产品“供不应求”的现象使人类不能充分利用现代计算机硬件提供的巨大潜力。</li></ul></li></ul><h3 id="1-1-3消除软件危机的途径"><a href="#1-1-3消除软件危机的途径" class="headerlink" title="1.1.3消除软件危机的途径"></a>1.1.3消除软件危机的途径</h3><ul><li>为了消除软件危机，首先应该对计算机软件有一个正确的认识。</li><li>软件=程序+数据+文档</li><li>1）加快新一代计算机的研制工作；<br>2）应该有组织，有计划，通过严格的管理手段进行软件的开发；<br>3）及时总结软件开发的成功技术和方法并加以推广；<br>4）应该选择好的开发工具进行软件的开发</li></ul><h2 id="1-2软件工程"><a href="#1-2软件工程" class="headerlink" title="1.2软件工程"></a>1.2软件工程</h2><h3 id="1-2-1软件工程的介绍"><a href="#1-2-1软件工程的介绍" class="headerlink" title="1.2.1软件工程的介绍"></a>1.2.1软件工程的介绍</h3><ul><li><p>软件工程是：①把系统的、规范的、可度量的途径应用于软件开发、运行、维护过程，也就是把工程应用于软件；②研究①中提到的途径。</p></li><li><p>软件工程的本质特性</p><ul><li>1.软件工程关注于大型程序的构造</li><li>2.软件工程的中心课题是控制系统复杂性</li><li>3.软件经常变化</li><li>4.开发软件的效率非常重要</li><li>5.和谐的合作是开发软件的关键</li><li>6.软件必须有效地支持它的用户</li><li>7.在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品</li></ul></li></ul><h3 id="1-2-2软件工程的基本原理"><a href="#1-2-2软件工程的基本原理" class="headerlink" title="1.2.2软件工程的基本原理"></a>1.2.2软件工程的基本原理</h3><ul><li>1.用分阶段的生命周期计划严格管理</li><li>2.坚持进行阶段评审</li><li>3.实行严格的产品控制</li><li>4.采用现代程序设计技术</li><li>5.结果应能清楚地审查</li><li>6.开发小组的人员应该少而精</li><li>7.承认不断改进软件工程时间的必要性</li></ul><h3 id="1-2-3软件工程方法学"><a href="#1-2-3软件工程方法学" class="headerlink" title="1.2.3软件工程方法学"></a>1.2.3软件工程方法学</h3><ul><li><p>通常把在软件生命周期全过程使用的一整套技术方法的集合称为方法学，也称为范型。</p></li><li><p>软件工程方法学包含3个要素：方法、工具和过程，方法是主导，工具是辅助</p><ul><li>过程：为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</li><li>方法：完成软件开发的各项任务的技术方法，回答“怎样做”的问题；</li><li>工具：为运用方法而提供的自动的或半自动的软件工程支撑环境</li></ul></li><li><p>软件工程的目标</p><ul><li>在给定成本、进度的前提下，开发出满足用户需求的高质量的、易于维护的软件产品。</li><li>软件工程是从技术和管理两方面研究如何更好地开发和维护计算机软件。</li><li>成本、进度和质量将是未来若干年中导致软件激烈竞争的主要因素。</li></ul></li><li><p>软件工程面临的问题</p><ul><li>软件费用仍然很高。</li><li>可靠性难以稳定地保证。</li><li>可维护性差。</li><li>可重用性低。</li><li>生产率不能有效提高。</li></ul></li><li><p>传统方法学（生命周期法或结构化范型）</p><ul><li>这种方法学把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。</li></ul></li><li><p>面向对象方法学</p><ul><li><p>面向对象方法是把数据和行为看成同等重要，是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。面向对象方法学有下述4个要点：</p><ul><li>（1）把对象作为融合了数据及在数据上的操作行为的统一的软件构建。</li><li>（2）把所有对象都划分成类</li><li>（3）按照父类（或称基类）与子类（或称为派生类）的关系，把若干个相关类组成一个层次结构的系统。</li><li>（4）对象彼此间仅能通过发送消息互相联系。</li></ul></li></ul></li></ul><h2 id="1-3软件生命周期"><a href="#1-3软件生命周期" class="headerlink" title="1.3软件生命周期"></a>1.3软件生命周期</h2><h3 id="软件定义"><a href="#软件定义" class="headerlink" title="软件定义"></a>软件定义</h3><ul><li><p>问题定义</p><ul><li>要解决的问题是什么？</li></ul></li><li><p>可行性研究</p><ul><li>对于上一个阶段所确定的问题有行得通的解决办法吗？</li></ul></li><li><p>需求分析</p><ul><li>为了解决这个问题，目标系统必须做什么？</li></ul></li></ul><h3 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h3><ul><li><p>总体设计</p><ul><li>概括地说，应该怎样实现目标系统？</li></ul></li><li><p>详细设计</p><ul><li>应该怎样具体实现这个系统呢？</li></ul></li><li><p>编码和单元测试</p><ul><li>写出正确的容易理解、容易维护的程序模块</li></ul></li><li><p>综合测试</p><ul><li>通过各种类型的测试（及相应的调试）使软件达到预定的要求。</li></ul></li></ul><h3 id="运行和维护"><a href="#运行和维护" class="headerlink" title="运行和维护"></a>运行和维护</h3><ul><li><p>软件维护</p><ul><li>通过各种必要的维护性活动使系统持久地满足用户的需求</li><li>改正性维护</li><li>适应性维护</li><li>完善性维护</li><li>预防性维护</li></ul></li></ul><h2 id="1-4软件过程"><a href="#1-4软件过程" class="headerlink" title="1.4软件过程"></a>1.4软件过程</h2><h3 id="1-4-1瀑布模型"><a href="#1-4-1瀑布模型" class="headerlink" title="1.4.1瀑布模型"></a>1.4.1瀑布模型</h3><ul><li>1.阶段间具有顺序性和依赖性</li><li>2.推迟实现的观点</li><li>3.质量保证的观点</li><li>优点：<ul><li>可强迫开发人员采用规范的方法；</li><li>严格地规定了每个阶段必须提交的文档；</li><li>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。</li><li>对文档的约束，使软件维护变得容易一些，且能降低软件预算</li></ul></li><li>缺点：<ul><li>开发过程一般不能逆转，否则代价太大；</li><li>实际的项目开发很难严格按该模型进行；</li><li>客户往往很难清楚地给出所有需求；</li><li>软件的实际情况必须到项目开发的后期客户才能看到</li></ul></li><li>适用范围：<ul><li>用户的需求非常清楚全面，且在开发过程中没有或很少变化</li><li>开发人员对软件的应用领域很熟悉</li><li>用户的使用环境非常稳定</li><li>开发工作对用户参与的需求很低</li></ul></li></ul><h3 id="1-4-2快速原型模型"><a href="#1-4-2快速原型模型" class="headerlink" title="1.4.2快速原型模型"></a>1.4.2快速原型模型</h3><ul><li>快速原型是快速建立起来的可以在计算机上运行的程序，它能完成的功能往往是最终产品能完成的功能的一个子集。</li><li>优点：<ul><li>可以得到比较好的需求分析定义，容易使用需求的变化；</li><li>有利于开发与培训同步；</li><li>开发费用低，开发周期短且对用户更友好。</li></ul></li><li>缺点：<ul><li>客户与开发者对原型理解不同；</li><li>准确的原型设计比较困难；</li><li>不利于开发人员的创新；</li></ul></li><li>适用范围：<ul><li>对所开发的领域比较熟悉而且有快速的原型开发工具；</li><li>项目招投标时，可以用原型模型作为软件的开发模型</li><li>进行产品移植或升级时，或对已有原型进行客户工作化时。</li></ul></li></ul><h3 id="1-4-3增量模型"><a href="#1-4-3增量模型" class="headerlink" title="1.4.3增量模型"></a>1.4.3增量模型</h3><ul><li>使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。</li><li>优点：<ul><li>能在短时间内向用户提交可完成部分工作的产品</li><li>逐步增加功能，减少了全新的软件可能给客户组织带来的冲击</li></ul></li><li>缺点：<ul><li>并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；</li><li>增量模型的灵活性很容易退化成边做边改模型，从而使软件过程的控制失去整体性。</li></ul></li><li>适用范围：<ul><li>进行已有产品升级或新版本开发；</li><li>对完成期限严格要求的产品</li><li>对所开发的领域比较熟悉而且已有原型系统。</li></ul></li></ul><h3 id="1-4-4螺旋模型"><a href="#1-4-4螺旋模型" class="headerlink" title="1.4.4螺旋模型"></a>1.4.4螺旋模型</h3><ul><li>基本思想是，使用原型及其他方法来尽量降低风险</li><li>优点：<ul><li>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量组为软件开发的一个重要目标；</li><li>减少了过多测试或测试不足所带来的分线；</li><li>在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别。</li></ul></li><li>缺点：<ul><li>需要丰富的风险评估经验和专门知识，如果未能够即使标识风险，会造成重大损失</li><li>过多的迭代次数会增加开发成本，延迟提交时间。</li></ul></li><li>适用范围：<ul><li>适用于内部开发的大规模软件项目</li></ul></li></ul><h3 id="1-4-5喷泉模型"><a href="#1-4-5喷泉模型" class="headerlink" title="1.4.5喷泉模型"></a>1.4.5喷泉模型</h3><ul><li>”喷泉“这个词体现了面向对象软件开发过程迭代和无缝的特性。</li><li>为避免使用喷泉模型开发软件时开发过程过分无序，应该把一个线性过程作为总目标</li></ul><h3 id="1-4-6Rational统一过程"><a href="#1-4-6Rational统一过程" class="headerlink" title="1.4.6Rational统一过程"></a>1.4.6Rational统一过程</h3><ul><li><p>最佳实践</p><ul><li>迭代式开发</li><li>管理需求</li><li>使用基于构件的体系结构</li><li>可视化建模（UML）</li><li>验证软件质量</li><li>控制软件变更</li></ul></li><li><p>RUP软件开发生命周期</p><ul><li><p>（1）核心工作流</p><ul><li>业务建模</li><li>需求</li><li>分析与设计</li><li>实现</li><li>测试</li><li>部署</li><li>配置与变更管理</li><li>项目管理</li><li>环境</li></ul></li><li><p>（2）工作阶段</p><ul><li>初始阶段</li><li>精化阶段</li><li>构建阶段</li><li>移交阶段</li></ul></li></ul></li></ul><h3 id="1-4-7敏捷过程与极限编程"><a href="#1-4-7敏捷过程与极限编程" class="headerlink" title="1.4.7敏捷过程与极限编程"></a>1.4.7敏捷过程与极限编程</h3><ul><li><p>敏捷过程</p><ul><li>个体和交互胜过过程和工具—合作、沟通交互更重要</li><li>可以工作的软件胜过面面俱到的文档</li><li>客户合作胜过合同谈判</li><li>相应变化胜过遵循计划</li></ul></li><li><p>极限编程。把好的开发实践运用到极致。极限编程广泛应用于需求模糊且经常改变的场合。</p><ul><li>客户作为开发团队成员</li><li>使用用户素材</li><li>短交付周期—反复迭代，每次完成部分需求</li><li>验收测试</li><li>结对编程—两人在用一台机器上共同编写同一程序，编码；审查测试</li><li>测试驱动开发—先设计测试方案，再编程，所有测试通过才能结束</li><li>集体所有—代码归属集体，每个成员都可以修改，都对全部代码质量负责</li><li>持续集成— 一天之内多次集成系统，根据需求变化，不断进行回归测试</li><li>可持续的开发速度</li><li>开放的工作空间—在同一场所一起工作，方便自由交流讨论</li><li>及时调整计划</li><li>简单的设计</li><li>代码重构—在不改变系统行为的前提下，重新调整和优化系统内部结构，以提高系统性能</li><li>使用隐喻—把隐喻看成是系统的全局视图，描述系统如何运作</li></ul></li></ul><h3 id="1-4-8微软过程"><a href="#1-4-8微软过程" class="headerlink" title="1.4.8微软过程"></a>1.4.8微软过程</h3><ul><li><p>基本准则</p><ul><li>项目计划应该兼顾未来的不确定因素</li><li>有用效的风险管理来减少不确定因素的影响</li><li>经常生成并快速地测试软件的过渡版本，以提高软件的稳定性和可预测性</li><li>采用快速循环、递进的开发过程</li><li>项目进度表应该具有较高稳定性和权威性</li><li>使用小型项目组并发地完成开发工作</li><li>使用原型验证概念，对项目进行早期论证</li><li>把零缺陷作为追求的目标</li><li>里程碑评审会的目的是改进工作，切记相互指责</li></ul></li><li><p>生命周期</p><ul><li>微软过程把软件生命周期分为5个阶段，即规划、设计、开发、稳定、发布。各阶段有里程碑。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 期中复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程多进程与协程</title>
      <link href="2020/08/28/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"/>
      <url>2020/08/28/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在介绍多线程之前，首先需要熟悉并发和并行，同步和异步的概念。如果阅读完本文章后仍对并发和并行、同步和异步的概念不太理解，没有关系，可以通过代码来慢慢了解这些概念的意义。</p></blockquote><h2 id="1-0基础概念解释"><a href="#1-0基础概念解释" class="headerlink" title="1.0基础概念解释"></a>1.0基础概念解释</h2><h3 id="1-1并发和并行"><a href="#1-1并发和并行" class="headerlink" title="1.1并发和并行"></a>1.1并发和并行</h3><p>  <strong>并发</strong>（concurrency）和<strong>并行</strong>（parallelism）是两个相似的概念。引用一个比较容易理解的说法，并发是指在一个时间段内发生若干时间的情况，并行是指在同一时刻发生若干事件的情况。</p><p>  这个概念用单核CPU和多核CPU比较容易说明。在使用单核CPU是，多个工作任务是以并发的方式运行的，因为只有一个CPU，所以各个任务会分别占用CPU的一段时间依次执行。如果在自己分得的时间段没有完成任务，就会切换到另一个任务，然后在下一次得到CPU使用权的时候再继续执行，以此类推，直到完成任务。在这种情况下，因为各个任务的时间段很短、经常切换，所以给我们的感觉是“同时”进行。在使用多核CPU时，在各个核的任务能够同时运行，也就是并行。</p><h3 id="1-2同步和异步"><a href="#1-2同步和异步" class="headerlink" title="1.2同步和异步"></a>1.2同步和异步</h3><p>  同步和异步也是两个值得比较的概念。下面在并发和并行框架的基础上理解同步和异步，同步就是并发或并行的各个任务不是独自运行的，任务之间有一定的交替顺序，可能在运行完成一个任务得到结果后，另一个任务才会开始运行。就像接力赛跑一样、要拿到交接棒之后下一个选手才可以开始跑。</p><p>  异步则是并发或并行的各个任务可以独立运行，一个任务的运行不受另一个任务影响，任务之间就像比赛的各个选手在不同的赛道比赛一样，跑步的速度不受其他赛道选手的影响。</p><h2 id="2-0多线程"><a href="#2-0多线程" class="headerlink" title="2.0多线程"></a>2.0多线程</h2><p><strong>_thread模块</strong><a href="https://docs.python.org/zh-cn/3/library/_thread.html#module-_thread">官方文档说明</a></p><p><strong>threading</strong><a href="https://docs.python.org/zh-cn/3/library/threading.html">官方文档说明</a></p><p>如果要使用多线程，那么需要先了解Python中使用多线程的两种方法。</p><ul><li>函数式：调用<strong>_thread</strong>模块中的**start_new_thread()**函数产生新线程。</li><li>类包装式：调用<strong>Threading</strong>库创建线程，从<strong>threading.Thread</strong>继承。</li></ul><h3 id="2-1-thread模块"><a href="#2-1-thread模块" class="headerlink" title="2.1_thread模块"></a>2.1_thread模块</h3><p>首先介绍函数式，在Python3中不能继续使用thread模块。为了兼容性考虑，Python3将<strong>thread</strong>重命名为<strong>_thread</strong>。</p><p>下面用实例感受一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#为线程定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay</span>):</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    time.sleep(delay)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    print(threadName,time.ctime(time.time()))</span><br><span class="line"><span class="comment">#创建两个线程</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  _thread.start_new(print_time, (<span class="string">&#x27;Thread-1&#x27;</span>,<span class="number">1</span>))</span><br><span class="line">  _thread.start_new(print_time, (<span class="string">&#x27;Thread-2&#x27;</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  print(<span class="string">&#x27;Error:无法启动线程&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果主线程结束的话，其他线程也会随之结束</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  print(<span class="string">&#x27;Main Finished&#x27;</span>)</span><br><span class="line">  time.sleep(<span class="number">15</span>)</span><br><span class="line">  <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>运行上述代码得到的结果是：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Main Finished </span><br><span class="line"></span><br><span class="line">Thread-1 Thu Aug 20 03:15:31 2020 </span><br><span class="line"></span><br><span class="line">Thread-1 Thu Aug 20 03:15:32 2020 </span><br><span class="line"></span><br><span class="line">Thread-2 Thu Aug 20 03:15:32 2020 </span><br><span class="line"></span><br><span class="line">Thread-1 Thu Aug 20 03:15:33 2020 </span><br><span class="line"></span><br><span class="line">Thread-2 Thu Aug 20 03:15:34 2020 </span><br><span class="line"></span><br><span class="line">Thread-2 Thu Aug 20 03:15:36 2020</span><br></pre></td></tr></table></figure><p><strong>_thread</strong>中使用**start_new_thread()**函数来产生新线程，语法如下：</p><blockquote><p><strong>_thread.start_new_thread(<em>function</em>, <em>args</em>[, <em>kwargs</em>])</strong></p></blockquote><p>其中，function表示线程函数，在上例中为<em>print_time</em>；<em>args</em>为传递给线程函数的参数，它必须是<em>tuple</em>类型，在上例中为*(‘Thread-1’, 1)*；可选的 <em>kwargs</em> 参数指定一个关键字参数字典。</p><h3 id="2-2threading模块"><a href="#2-2threading模块" class="headerlink" title="2.2threading模块"></a>2.2threading模块</h3><p>_thread提供了低级别、原始的线程，它相比于threading模块，功能还是比较有限的。threading模块提供了<em>Thread</em>类来处理线程，threading 模块除了包含 _thread 模块中的所有方法外，包括以下方法。</p><ul><li>threading.currentThread(): 返回当前的线程变量。</li><li>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</li><li>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</li></ul><p>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</p><ul><li><p><strong>run():</strong> 用以表示线程活动的方法。</p></li><li><p>**start():**启动线程活动。</p></li><li><p><strong>join([time]):</strong> 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</p></li><li><p><strong>isAlive():</strong> 返回线程是否活动的。</p></li><li><p><strong>getName():</strong> 返回线程名。</p></li><li><p><strong>setName():</strong> 设置线程名。</p></li><li><p><strong>setDaemon(bool)</strong></p><p>一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 <code>start()</code>前设置好，不然会抛出 <code>RuntimeError</code> 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 <code>daemon</code> = <code>False</code>。当没有存活的非守护线程时，整个Python程序才会退出。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, counter</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开始线程：&quot;</span> + self.name)</span><br><span class="line">        print_time(self.name, self.counter, <span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;退出线程：&quot;</span> + self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay, counter</span>):</span></span><br><span class="line">    <span class="keyword">while</span> counter:</span><br><span class="line">        <span class="keyword">if</span> exitFlag:</span><br><span class="line">            threadName.exit()</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line">thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">开始线程：Thread-1 </span><br><span class="line"></span><br><span class="line">开始线程：Thread-2 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:24 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:25 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:25 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:26 2020</span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:27 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:27 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:28 2020 </span><br><span class="line"></span><br><span class="line">退出线程：Thread-1 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:29 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:31 2020</span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:33 2020 </span><br><span class="line"></span><br><span class="line">退出线程：Thread-2 </span><br><span class="line"></span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><h3 id="2-3线程同步"><a href="#2-3线程同步" class="headerlink" title="2.3线程同步"></a>2.3线程同步</h3><h4 id="2-3-1线程同步说明"><a href="#2-3-1线程同步说明" class="headerlink" title="2.3.1线程同步说明"></a>2.3.1线程同步说明</h4><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</p><p>使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：</p><p>多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。</p><p>考虑这样一种情况：一个列表里所有元素都是0，线程”set”从后向前把所有元素改成1，而线程”print”负责从前往后读取列表并打印。</p><p>那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。</p><p>锁有两种状态——锁定和未锁定。每当一个线程比如”set”要访问共享数据时，必须先获得锁定；如果已经有别的线程比如”print”获得锁定了，那么就让线程”set”暂停，也就是同步阻塞；等到线程”print”访问完毕，释放锁以后，再让线程”set”继续。</p><p>经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。</p><h4 id="2-3-2示例代码"><a href="#2-3-2示例代码" class="headerlink" title="2.3.2示例代码"></a>2.3.2示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, counter</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程： &quot;</span> + self.name)</span><br><span class="line">        <span class="comment"># 获取锁，用于线程同步</span></span><br><span class="line">        threadLock.acquire()</span><br><span class="line">        print_time(self.name, self.counter, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line">        threadLock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay, counter</span>):</span></span><br><span class="line">    <span class="keyword">while</span> counter:</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threadLock = threading.Lock()</span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line">thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加线程到线程列表</span></span><br><span class="line">threads.append(thread1)</span><br><span class="line">threads.append(thread2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">开启线程： Thread-1 </span><br><span class="line"></span><br><span class="line">开启线程： Thread-2 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 04:06:06 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 04:06:07 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 04:06:08 2020</span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 04:06:10 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 04:06:12 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 04:06:14 2020 </span><br><span class="line"></span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><h3 id="2-4线程优先级队列（Queue）"><a href="#2-4线程优先级队列（Queue）" class="headerlink" title="2.4线程优先级队列（Queue）"></a>2.4线程优先级队列（Queue）</h3><h4 id="2-4-1Queue模块基本说明"><a href="#2-4-1Queue模块基本说明" class="headerlink" title="2.4.1Queue模块基本说明"></a>2.4.1Queue模块基本说明</h4><p>Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。</p><p>这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p><p>Queue 模块中的常用方法:</p><ul><li><code>Queue.qsize</code>() 返回队列的大小</li><li><code>Queue.empty</code>() 如果队列为空，返回True,反之False</li><li><code>Queue.full</code>() 如果队列满了，返回True,反之False</li><li><code>Queue.full</code> 与 <code>maxsize</code> 大小对应</li><li><code>Queue.get</code>([block[, timeout]])获取队列，timeout等待时间</li><li><code>Queue.get_nowait(</code>) 相当<code>Queue.get</code>(False)</li><li><code>Queue.put</code>(item) 写入队列，timeout等待时间</li><li><code>Queue.put_nowait</code>(item) 相当<code>Queue.put</code>(item, False)</li><li><code>Queue.task_done</code>() 在完成一项工作之后，<code>Queue.task_done</code>()函数向任务已经完成的队列发送一个信号</li><li><code>Queue.join</code>() 实际上意味着等到队列为空，再执行别的操作</li></ul><h4 id="2-4-1示例代码"><a href="#2-4-1示例代码" class="headerlink" title="2.4.1示例代码"></a>2.4.1示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, q</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.q = q</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程：&quot;</span> + self.name)</span><br><span class="line">        process_data(self.name, self.q)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;退出线程：&quot;</span> + self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_data</span>(<span class="params">threadName, q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exitFlag:</span><br><span class="line">        queueLock.acquire()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> workQueue.empty():</span><br><span class="line">            data = q.get()</span><br><span class="line">            queueLock.release()</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;%s processing %s&quot;</span> % (threadName, data))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queueLock.release()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">threadList = [<span class="string">&quot;Thread-1&quot;</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="string">&quot;Thread-3&quot;</span>]</span><br><span class="line">nameList = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>]</span><br><span class="line">queueLock = threading.Lock()</span><br><span class="line">workQueue = queue.Queue(<span class="number">10</span>)</span><br><span class="line">threads = []</span><br><span class="line">threadID = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line"><span class="keyword">for</span> tName <span class="keyword">in</span> threadList:</span><br><span class="line">    thread = myThread(threadID, tName, workQueue)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    threadID += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充队列</span></span><br><span class="line">queueLock.acquire()</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> nameList:</span><br><span class="line">    workQueue.put(word)</span><br><span class="line">queueLock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待队列清空</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> workQueue.empty():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知线程是时候退出</span></span><br><span class="line">exitFlag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><p>由于Queue是线程安全的队列，故不用<code>Lock</code>对象来进行线程同步也可以，下面代码和上述代码得到的结果一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, q</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.q = q</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程：&quot;</span> + self.name)</span><br><span class="line">        process_data(self.name, self.q)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;退出线程：&quot;</span> + self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_data</span>(<span class="params">threadName, q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exitFlag:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> workQueue.empty():</span><br><span class="line">            data = q.get()</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;%s processing %s&quot;</span> % (threadName, data))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">threadList = [<span class="string">&quot;Thread-1&quot;</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="string">&quot;Thread-3&quot;</span>]</span><br><span class="line">nameList = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>]</span><br><span class="line">workQueue = queue.Queue(<span class="number">10</span>)</span><br><span class="line">threads = []</span><br><span class="line">threadID = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line"><span class="keyword">for</span> tName <span class="keyword">in</span> threadList:</span><br><span class="line">    thread = myThread(threadID, tName, workQueue)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    threadID += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充队列</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> nameList:</span><br><span class="line">    workQueue.put(word)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待队列清空</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> workQueue.empty():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知线程是时候退出</span></span><br><span class="line">exitFlag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">开启线程：Thread-1</span><br><span class="line">开启线程：Thread-2</span><br><span class="line">开启线程：Thread-3</span><br><span class="line">Thread-2 processing One</span><br><span class="line">Thread-3 processing Two</span><br><span class="line">Thread-1 processing Three</span><br><span class="line">Thread-2 processing Four</span><br><span class="line">Thread-3 processing Five</span><br><span class="line">退出线程：Thread-1</span><br><span class="line">退出线程：Thread-2</span><br><span class="line">退出线程：Thread-3</span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><h2 id="3-0多进程"><a href="#3-0多进程" class="headerlink" title="3.0多进程"></a>3.0多进程</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/08/21/hello-world/"/>
      <url>2020/08/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
