<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/20/hello-world/"/>
      <url>2020/11/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第五章</title>
      <link href="2020/11/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>2020/11/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="5-总体设计"><a href="#5-总体设计" class="headerlink" title="5.总体设计"></a>5.总体设计</h1><h2 id="5-1设计过程"><a href="#5-1设计过程" class="headerlink" title="5.1设计过程"></a>5.1设计过程</h2><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><ul><li>从工程管理的角度，可以将软件设计分为概要设计阶段和详细设计阶段。</li><li>从技术的角度，传统的结构化方法将软件设计划分为体系结构设计、数据设计、接口设计和过程设计4部分。</li><li>面向对象方法则将软件设计划分为体系结构设计、类设计/数据设计、接口设计和构件级设计4部分。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/368eaddd2b5038b4a78ca51dda1f861b.png"></li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/ceb8eac59f58336726bb549af2b2a260.png"></li></ul><h3 id="基本任务"><a href="#基本任务" class="headerlink" title="基本任务"></a>基本任务</h3><ul><li>（1）将软件系统划分成模块</li><li>（2）决定每个模块的功能</li><li>（3）决定模块的调用关系</li><li>（4）决定模块的界面，即模块间传递的数据</li></ul><h3 id="总体设计的过程"><a href="#总体设计的过程" class="headerlink" title="总体设计的过程"></a>总体设计的过程</h3><ul><li><p>系统设计阶段，确定系统的具体实现方案</p><ul><li>设想供选择的方案</li><li>选取合理的方案</li><li>推荐最佳方案</li></ul></li><li><p>结构设计阶段，确定软件结构</p><ul><li>功能分解</li><li>设计软件结构</li><li>设计数据库</li></ul></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>1．设想供选择的方案</p><ul><li>根据需求分析阶段得出的数据流图考虑各种可能的实现方案，力求从中选出最佳方案。即由逻辑模型——&gt;物理模型</li></ul></li><li><p>2．选取合理的方案</p><ul><li><p>从前一步得到的一系列供选择的方案中选取若干个合理的方案。通常，选取的这些方案中至少应包括低成本、中成本和高成本的三种方案类型。对每个合理的方案分析员都应该准备下列4份资料：对每个合理方案要提供以下几方面资料：</p><ul><li>（1）系统流程图；</li><li>（2）组成系统的物理元素清单 ；</li><li>（3）成本／效益分析；</li><li>（4）实现这个系统的进度计划。</li></ul></li></ul></li><li><p>3．推荐最佳方案</p><ul><li>分析员从合理方案中选择一个最佳方案向用户推荐，并为推荐的方案制定详细的实现计划。对于分析员推荐的最佳方案，用户和有关专家应该认真审查。如果确认该方案确实符合用户的需要，并且在现有条件下完全能够实现，则应该提请使用部门负责人进一步审批。在使用部门负责人也接受了分析员所推荐的方案之后，方可进入总体设计过程的下一步工作，即结构设计阶段。</li></ul></li><li><p>4．功能分解</p><ul><li><p>（1）结构设计 —— 总体设计阶段的任务</p><ul><li>结构设计确定程序由哪些模块组成，以及这些模块之间的关系；</li></ul></li><li><p>（2）过程设计 —— 详细设计阶段的任务</p><ul><li>过程设计确定每个模块的处理过程。主要是按照用户的要求把复杂的功能从实现的角度进行分解，以方便后面软件结构的确定</li></ul></li></ul></li><li><p>5.设计软件结构</p><ul><li>通常程序中的一个模块完成一个适当的子功能。应该把模块组织成良好的层次系统。软件结构可以用层次图或结构图来描绘。</li><li>如果数据流图已经细化到适当的层次，则可以直接从数据流图映射出软件结构，这就是面向数据流的设计方法。</li></ul></li><li><ol start="6"><li>设计数据库</li></ol><ul><li><p>数据库设计的主要工作是：</p><ul><li>1）设计数据库的表，表的结构就是数据的存储结构</li><li>2）对这些表中的数据进行操作。</li></ul></li><li><p>数据库设计的主要挑战是“高速度处理大容量的数据”</p></li><li><p>数据库设计的步骤:</p><ul><li>逻辑设计</li><li>物理设计</li><li>安全性设计</li><li>性能优化</li></ul></li></ul></li><li><p>7．制定测试计划</p><ul><li>在软件开发的早期阶段提前考虑软件的测试计划是很有必要的。这样能促使软件设计人员在设计时注意到软件的测试问题，从而有利于提高软件的可测试性。 </li></ul></li><li><p>8．书写文档</p><ul><li>（1）总体设计说明书（包括系统实现方案和软件模块结构）；</li><li>（2）测试计划（包括测试策略、测试方案、预测的测试结果、测试进度计划等）；</li><li>（3）用户手册（根据总体设计阶段的结果，编写的初步的用户操作手册）；</li><li>（4）详细的实现计划；</li><li>（5）数据库设计结果。</li></ul></li><li><ol start="9"><li>审查和复审</li></ol><ul><li>最后应该对总体设计的结果进行严格的技术审查，在技术审查通过之后再由使用部门的负责人从管理角度进行复审。</li></ul></li></ul><h2 id="5-2设计原理"><a href="#5-2设计原理" class="headerlink" title="5.2设计原理"></a>5.2设计原理</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li><p>定义：</p><ul><li>模块是数据说明、可执行语句等程序对象的集合，它是单独命名的，可通过名字来进行访问。</li></ul></li><li><p>特点：</p><ul><li>一个模块具有输入和输出、功能、内部数据和程序代码等四个特性。</li><li>输入输出和功能构成一个模块的外貌，即模块的外部特性。</li><li>内部数据和程序代码是模块的内部特性。</li></ul></li><li><p>模块化</p><ul><li>模块化就是把程序划分成若干个模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能，满足用户的需求</li><li>特点：先分解，然后再集成</li><li>软件模块化设计的指导思想是分解、抽象、逐步求精、信息隐蔽和模块独立性。</li></ul></li><li><p>为什么要模块化？</p><ul><li>模块化是为了使一个复杂的大型程序能被人的智力所管理，软件应该具备的惟一属性。</li><li>如果一个大型程序仅由一个模块组成，它将很难被人所理解。</li></ul></li><li><p>评价一种设计方法定义模块能力的五条标准：</p><ul><li>模块可分解性     </li><li>模块可组装性 </li><li>模块可理解性</li><li>模块连续性 </li><li>模块保护性</li></ul></li><li><p>模块化的作用：</p><ul><li>采用模块化原理可以使软件结构清晰，不仅容易设计也容易阅读和理解。</li><li>模块化使软件容易测试和调试，因而有助于提高软件的可靠性。</li><li>模块化能够提高软件的可修改性。</li><li>模块化也有助于软件开发工程的组织管理。</li></ul></li></ul><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><ul><li><p>定义</p><ul><li>现实世界中一定事物、状态或过程之间总存在着某些相似的方面(共性)。把这些相似的方面集中和概括起来，暂时忽略它们之间的差异，这就是抽象。</li><li>抽象就是抽出事物本质特性而暂时不考虑细节。</li></ul></li><li><p>一般抽象过程：</p><ul><li>处理复杂系统的惟一有效的方法是用层次的方式构造和分析它。</li><li>一个复杂的动态系统首先可以用一些高级的抽象概念构造和理解，这些高级概念又可以用一些较低级的概念构造和理解，如此进行下去，直至最低层次的具体元素。 </li><li>例：过程抽象、数据抽象</li></ul></li><li><p>软件工程抽象过程：</p><ul><li>软件工程过程的每一步都是对软件解法的抽象层次的一次精化。</li><li>在可行性研究阶段，软件作为系统的一个完整部件</li><li>在需求分析阶段，软件解法是使用在问题环境内熟悉的方式描述</li><li>进入总体设计向详细设计过渡阶段，抽象的程度将随之减少</li><li>最后当源程序被写出以后，抽象就达到最低层。</li></ul></li></ul><h3 id="逐步求精"><a href="#逐步求精" class="headerlink" title="逐步求精"></a>逐步求精</h3><ul><li><p>介绍：</p><ul><li>为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。逐步求精是人类解决复杂问题时采用的基本方法，也是许多软件工程技术的基础。</li></ul></li><li><p>Miller法则：</p><ul><li>一个人在任何时候都只能把注意力集中在（7±2）个知识块上。</li></ul></li><li><p>抽象与求精的关系</p><ul><li>抽象与求精是一对互补的概念。抽象使得设计者能够说明过程和数据，同时却忽略低层细节。求精则帮助设计者在设计过程中逐步揭示出低层细节。</li></ul></li><li><p>逐步求精的作用：</p><ul><li>它能帮助软件工程师把精力集中在与当前开发阶段最相关的那些方面上，而忽略那些对整体解决方案来说虽然是必要的，然而目前还不需要考虑的细节。</li><li>逐步求精方法确保每个问题都将被解决，而且每个问题都将在适当的时候被解决，但是，在任何时候一个人都不需要同时处理7个以上知识块。</li></ul></li></ul><h3 id="信息隐藏和局部化"><a href="#信息隐藏和局部化" class="headerlink" title="信息隐藏和局部化"></a>信息隐藏和局部化</h3><ul><li><p>信息隐藏原理：</p><ul><li>应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。</li></ul></li><li><p>局部化：</p><ul><li>局部化的概念和信息隐藏概念是密切相关的。所谓局部化是指把一些关系密切的软件元素物理地放得彼此靠近。显然，局部化有助于实现信息隐藏。</li></ul></li><li><p>作用：</p><ul><li>“隐藏”意味着有效的模块化可以通过定义一组独立的模块而实现，这些独立的模块彼此间仅仅交换那些为了完成系统功能而必须交换的信息。</li><li>使用信息隐藏原理作为模块化系统设计的标准就会带来极大好处。因为绝大多数数据和过程对于软件的其他部分而言是隐藏的，在修改期间由于疏忽而引入的错误就很少可能传播到软件的其他部分。</li></ul></li></ul><h3 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h3><ul><li><p>定义：</p><ul><li>模块独立的概念是模块化、抽象、信息隐藏和局部化概念的直接结果。</li><li>希望这样设计软件结构，使得每个模块完成一个相对独立的特定子功能，并且和其他模块之间的关系很简单。 </li></ul></li><li><p>模块独立的重要性：</p><ul><li>有效的模块化(即具有独立的模块)的软件比较容易开发出来。这是由于能够分割功能而且接口可以简化，当许多人分工合作开发同一个软件时，这个优点尤其重要。</li><li>独立的模块比较容易测试和维护。这是因为相对说来，修改设计和程序需要的工作量比较小，错误传播范围小，需要扩充功能时能够“插入”模块。</li></ul></li><li><p>模块独立程度的两个定性标准度量：</p><ul><li>耦合衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低，即每个模块和其他模块之间的关系要简单；</li><li>内聚衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高，每个模块完成一个相对独立的特定子功能。</li><li>模块独立性愈高，则块内联系越强（内聚性强/高），块间联系越弱（耦合度弱/低）。</li></ul></li><li><p>耦合——块间联系</p><ul><li>耦合：是对一个软件结构内不同模块之间互连程度的度量。</li><li>要求：在软件设计中应该追求尽可能松散耦合的系统。</li><li>可以研究、测试或维护任何一个模块，而不需要对系统的其他模块有很多了解；</li><li>模块间联系简单，发生在一处的错误传播到整个系统的可能性就很小；</li><li>模块间的耦合程度强烈影响系统的可理解性、可测试性、可靠性和可维护性。</li></ul></li><li><p>耦合程度的度量：</p><ul><li><p>(1) 非直接耦合/完全独立</p><ul><li>如果两个模块中的每一个都能独立地工作而不需要另一个模块的存在，那么它们完全独立。</li><li>在一个软件系统中不可能所有模块之间都没有任何连接。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/cd690936362cc449c8c172ff8af81366.png"></li></ul></li><li><p>(2) 数据耦合</p><ul><li><p>如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/f7193282ed9c4e9463a0424b4f6309b6.png"></p></li><li><p>评价：</p><ul><li>系统中至少必须存在这种耦合。一般说来，一个系统内可以只包含数据耦合。</li><li>数据耦合是理想的目标。</li><li>维护更容易，对一个模块的修改不会是另一个模块产生退化错误。</li></ul></li></ul></li><li><p>(3) 控制耦合</p><ul><li><p>如果两个模块彼此间传递的信息中有控制信息，这种耦合称为控制耦合。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/5228fea9d02ddf5b08cfb8eda4983d46.png"></p></li><li><p>评价：</p><ul><li>控制耦合往往是多余的，把模块适当分解之后通常可以用数据耦合代替它。</li><li>被调用的模块需知道调用模块的内部结构和逻辑，降低了重用的可能性 。</li></ul></li></ul></li><li><p>(4) 特征耦合</p><ul><li><p>当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。</p></li><li><p>评价：</p><ul><li>被调用的模块可使用的数据多于它确实需要的数据，这将导致对数据的访问失去控制，从而给计算机犯罪提供了机会。</li><li>无论何时把指针作为参数进行传递，都应该仔细检查该耦合。</li></ul></li></ul></li><li><p>(5) 公共环境耦合</p><ul><li><p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等等。</p></li><li><p>公共环境耦合的类型：</p><ul><li><p>一个模块往公共环境送数据，另一个模块从公共环境取数据。数据耦合的一种形式，是比较松散的耦合。</p></li><li><p>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/858abea9497815abf58cbcaa58e0a037.png"></p></li><li><p>评价：</p><ul><li>与结构化编程矛盾，生成的代码完全不可读。</li><li>如果在一个模块中对一个全局变量的声明进行修改，必须修改能够访问该全局变量的每一个模块。</li><li>公共环境耦合的模块难于重用，必须提供一个全局变量的清单。</li><li>即使模块本身不改变，它和产品中其他模块之间公共环境耦合的实例数也会变化非常大。</li><li>潜在危险很大。模块暴露出必需要更多的数据，难以控制数据存取，而且会导致计算机犯罪。</li><li>有些情况下公共环境耦合更好。 </li></ul></li></ul></li></ul></li><li><p>(6) 内容耦合</p><ul><li><p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合：</p><ul><li>一个模块访问另一个模块的内部数据；</li><li>一个模块不通过正常入口转到另一个模块的内部；</li><li>两个模块有一部分程序代码重叠；</li><li>一个模块有多个入口。 </li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/1a8d73a9ea1d48b0b04ceb838f88580c.png"></li></ul></li></ul></li><li><p>设计原则：</p><ul><li>尽量使用数据耦合，</li><li>少用控制耦合和特征耦合，</li><li>限制公共环境耦合的范围。</li><li>完全不用内容耦合</li></ul></li></ul></li><li><p>内聚——块内联系</p><ul><li>内聚：标志一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然扩展。简单地说，理想内聚的模块只做一件事情。</li><li>要求：设计时应该力求做到高内聚，通常中等程度的内聚也是可以采用的，而且效果和高内聚相差不多；但是，低内聚不要使用。</li><li>内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。 </li></ul></li><li><p>内聚程度的度量：</p><ul><li><p>(1) 偶然内聚</p><ul><li><p>如果一个模块完成一组任务，这些任务彼此间即使有关系，关系也是很松散的，就叫做偶然内聚。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/eedfd07976671a946502416f4349c0ee.png"></p></li><li><p>评价：</p><ul><li>模块内各元素之间没有实质性联系，很可能在一种应用场合需要修改这个模块，在另一种应用场合又不允许这种修改，从而陷入困境；</li><li>可理解性差，可维护性产生退化；</li><li>模块是不可重用的。</li></ul></li><li><p>解决方案：</p><ul><li>将模块分成更小的模块，每个小模块执行一个操作。</li></ul></li></ul></li><li><p>(2) 逻辑内聚</p><ul><li><p>如果一个模块完成的任务在逻辑上属于相同或相似的一类，则称为逻辑内聚。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/814e1d65fb5b5fa7d84f50176883faff.png"></p></li><li><p>评价：</p><ul><li>接口难以理解，造成整体上不易理解；</li><li>完成多个操作的代码互相纠缠在一起，即使局部功能的修改有时也会影响全局，导致严重的维护问题；</li><li>难以重用。</li></ul></li><li><p>解决方案：</p><ul><li>模块分解。 </li></ul></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/409ca6a009821cf40d8757d5a963bae5.png"></p></li></ul></li><li><p>(3) 时间内聚</p><ul><li><p>如果一个模块包含的任务必须在同一段时间内执行，就叫时间内聚。</p></li><li><p>评价：</p><ul><li>时间关系在一定程度上反映了程序某些实质，所以时间内聚比逻辑内聚好一些。</li><li>模块内操作之间的关系很弱，与其他模块的操作却有很强的关联。</li><li>时间内聚的模块不太可能重用。</li></ul></li></ul></li><li><p>(4) 过程内聚</p><ul><li><p>如果一个模块内的处理元素是相关的，而且必须以特定次序执行，则称为过程内聚。</p></li><li><p>使用程序流程图作为工具设计软件时，常常通过研究流程图确定模块的划分，这样得到的往往是过程内聚的模块。 </p></li><li><p>评价：</p><ul><li>比时间内聚好，至少操作之间是过程关联的。</li><li>仍是弱连接，不太可能重用模块。</li></ul></li><li><p>解决方案：</p><ul><li>分割为单独的模块，每个模块执行一个操作。</li></ul></li></ul></li><li><p>(5) 通信内聚</p><ul><li><p>如果模块中所有元素都使用同一个输入数据和(或)产生同一个输出数据，则称为通信内聚。即在同一个数据结构上操作。</p></li><li><p>评价：</p><ul><li>模块中各操作紧密相连，比过程内聚更好。</li><li>不能重用。</li></ul></li><li><p>解决方案：</p><ul><li>分成多个模块，每个模块执行一个操作。</li></ul></li></ul></li><li><p>(6) 顺序内聚</p><ul><li><p>如果一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚。</p></li><li><p>评价：</p><ul><li>根据数据流图划分模块时，通常得到顺序内聚的模块，这种模块彼此间的连接往往比较简单。 </li></ul></li></ul></li><li><p>(7) 功能内聚</p><ul><li><p>如果模块内所有处理元素属于一个整体，完成一个单一的功能，则称为功能内聚。功能内聚是最高程度的内聚。</p></li><li><p>评价：</p><ul><li>模块可重用，应尽可能重用；</li><li>可隔离错误，维护更容易；</li><li>扩充产品功能时更容易。</li></ul></li></ul></li><li><p>七种内聚的优劣评分结果：</p><ul><li><p>高内聚：</p><ul><li>功能内聚     10分</li><li>顺序内聚        9分        </li></ul></li><li><p>中内聚：</p><ul><li>通信内聚          7分    </li><li>过程内聚          5分</li></ul></li><li><p>低内聚：</p><ul><li>时间内聚        3分</li><li>逻辑内聚        1分</li><li>偶然内聚        0分</li></ul></li></ul></li><li><p>总结：</p><ul><li>设计时力争做到高内聚，并且能够辨认出低内聚的模块。对于一个模块而言，模块自身的内聚越强，模块间的耦合就越小，模块所具有的独立性就越好，可以说高内聚低耦合是我们进行软件设计的一贯原则。</li></ul></li></ul></li></ul><h2 id="5-3启发规则"><a href="#5-3启发规则" class="headerlink" title="5.3启发规则"></a>5.3启发规则</h2><h3 id="1-改进软件结构提高模块独立性"><a href="#1-改进软件结构提高模块独立性" class="headerlink" title="1. 改进软件结构提高模块独立性"></a>1. 改进软件结构提高模块独立性</h3><ul><li><p>通过模块分解或合并，降低耦合提高内聚。</p><ul><li>例如，多个模块公有的一个子功能可以独立成一个模块，由这些模块调用；有时可以通过分解或合并模块以减少控制信息的传递及对全程数据的引用，并且降低接口的复杂程度。</li></ul></li><li><p>两个方面：</p><ul><li><p>模块功能完善化。一个完整的模块包含：</p><ul><li>执行规定的功能的部分</li><li>出错处理的部分</li><li>返回一个“结束标志”</li></ul></li><li><p>消除重复功能，改善软件结构。</p><ul><li><p>完全相似</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/0a77666bf80fa10165553c27daea43e0.png"></li></ul></li><li><p>局部相似</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/cebb572ff17fa518a9667e91373929a4.png"></li></ul></li></ul></li></ul></li></ul><h3 id="2-模块规模应该适中"><a href="#2-模块规模应该适中" class="headerlink" title="2. 模块规模应该适中"></a>2. 模块规模应该适中</h3><ul><li>经验表明，一个模块的规模不应过大，最好能写在一页纸内。通常规定50~100行语句，最多不超过500行。数字只能作为参考，根本问题是要保证模块的独立性。</li><li>过大的模块往往是由于分解不充分，但是进一步分解必须符合问题结构，一般说来，分解后不应该降低模块独立性。</li><li>过小的模块开销大于有效操作，而且模块数目过多将使系统接口复杂。</li></ul><h3 id="3-深度、宽度、扇出和扇入应适中"><a href="#3-深度、宽度、扇出和扇入应适中" class="headerlink" title="3. 深度、宽度、扇出和扇入应适中"></a>3. 深度、宽度、扇出和扇入应适中</h3><ul><li>深度: 表示软件结构中控制的层数，它往往能粗略地标志一个系统的大小和复杂程度。深度和程序长度之间应该有粗略的对应关系。</li><li>宽度: 表示软件结构中控制的总跨度。即同一个层次上的模块总数的最大值，宽度越大系统越复杂。</li><li>扇出：表示一个模块直接控制(调用)的模块数目。扇出为3－4，上限扇出为5－9。</li><li>扇入：表示有多个上级模块直接调用该模块，扇入越大则共享该模块的上级模块数目越多。</li><li>软件结构一般要求顶层扇出较大，中层扇出较少，底层扇入较大为好。</li></ul><h3 id="4-模块的作用域应该在控制域之内"><a href="#4-模块的作用域应该在控制域之内" class="headerlink" title="4. 模块的作用域应该在控制域之内"></a>4. 模块的作用域应该在控制域之内</h3><ul><li><p>模块的作用域是指受该模块内一个判定影响的所有模块的集合。</p></li><li><p>模块的控制域是包括自己以及所有下属模块的集合。</p></li><li><p>在一个设计得很好的系统中，所有受判定影响的模块应该都从属于做出判定的那个模块，最好局限于做出判定的那个模块本身及它的直属下级模块。</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/716dbec7703b75bcd3c3335882982256.png"></p><ul><li>第一，这种结构使得软件难于理解</li><li>第二，为了能影响到G，需要在A中设置标记，并把标记传递给M（A和G的公共上级），再由M传递给G。这个标记是控制信息不是数据，将使得模块间出现控制耦合。</li></ul></li><li><p>解决方案：</p><ul><li><p>使判定上移。把模块A中的判定移到模块M中；</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/4953208d6e2d01f6bbe8034de5550e82.png"></li></ul></li><li><p>受判定影响的模块下移。把模块G移到模块A下面，作为他的下级模块。</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/93b74b10dfb130df5e2e385c7a7cca99.png"></li></ul></li></ul></li></ul><h3 id="5-力争降低模块接口的复杂程度"><a href="#5-力争降低模块接口的复杂程度" class="headerlink" title="5. 力争降低模块接口的复杂程度"></a>5. 力争降低模块接口的复杂程度</h3><ul><li>模块接口复杂是软件发生错误的一个主要原因。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。</li></ul><h3 id="6-设计单入口单出口的模块"><a href="#6-设计单入口单出口的模块" class="headerlink" title="6. 设计单入口单出口的模块"></a>6. 设计单入口单出口的模块</h3><ul><li>这条启发式规则警告软件工程师不要使模块间出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。</li></ul><h3 id="7-模块功能应该可以预测"><a href="#7-模块功能应该可以预测" class="headerlink" title="7. 模块功能应该可以预测"></a>7. 模块功能应该可以预测</h3><ul><li>模块的功能应该能够预测，但也要防止模块功能过分局限。</li><li>功能可预测：如果一个模块可以当做一个黑盒子，只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。</li></ul><h3 id="8-组装软件要根据设计的约束和移植的需要"><a href="#8-组装软件要根据设计的约束和移植的需要" class="headerlink" title="8.组装软件要根据设计的约束和移植的需要"></a>8.组装软件要根据设计的约束和移植的需要</h3><h2 id="5-4描绘软件结构的图形工具"><a href="#5-4描绘软件结构的图形工具" class="headerlink" title="5.4描绘软件结构的图形工具"></a>5.4描绘软件结构的图形工具</h2><h3 id="1-层次图"><a href="#1-层次图" class="headerlink" title="1.层次图"></a>1.层次图</h3><ul><li><p>层次图用来描绘软件的层次结构。很适于在自顶向下设计软件的过程中使用。</p></li><li><p>层次图中的每个方框代表一个模块，方框间的连线表示调用关系，不同于层次方框图那样表示组成关系。</p></li><li><p>层次图和层次方框图的区别：</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/5538686b5bc943247c54f088d6a4dbbc.png"></li></ul></li><li><p>例：</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/77e65323f78594c3d6bb1e86fee21784.png"></li></ul></li></ul><h3 id="2-HIPO图"><a href="#2-HIPO图" class="headerlink" title="2.HIPO图"></a>2.HIPO图</h3><ul><li>HIPO图是美国IBM公司发明的“层次图+输入/处理/输出图”的英文缩写。</li><li>为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/b89d912fada504dff54ec25eea858387.png"></li></ul><h3 id="3-结构图"><a href="#3-结构图" class="headerlink" title="3.结构图"></a>3.结构图</h3><ul><li><p>结构图描述了程序的模块结构，表示了一个系统的层次分解关系，反映了块间联系和块内联系等特征及控制信息的传递关系。</p></li><li><p>基本图形符号：</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/c264da28bfcd6b94b515e7c11254eb57.png"></li></ul></li><li><p>选择调用：判定为真时调用A，为假时调用B。</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/7393138ab4cb62b7e723ae9f005dcea9.png"></li></ul></li><li><p>循环调用：模块M循环调用模块A、B、C。</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/c8e53e1fdcc2d7c69c2f0287c8c397fc.png"></li></ul></li><li><p>例子</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/44a3d0947fdc8eb0f3cb6ab71791ff6a.png"></li></ul></li><li><p>注意：</p><ul><li>层次图和结构图并不严格表示模块的调用次序，多数人习惯按调用次序从左到右画模块；</li><li>层次图和结构图并不指明何时调用下层模块；</li><li>层次图和结构图只表明一个模块调用那些模块，没有表示模块内还有没有其他成分；</li><li>通常用层次图作为描绘软件结构的文档；</li><li>由层次图导出结构图的过程，可以作为检查设计正确性和评价模块独立性的好方法。</li></ul></li></ul><h2 id="5-5面向数据流的设计方法（SD方法）"><a href="#5-5面向数据流的设计方法（SD方法）" class="headerlink" title="5.5面向数据流的设计方法（SD方法）"></a>5.5面向数据流的设计方法（SD方法）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>面向数据流的设计方法把信息流映射成软件结构，信息流的类型决定了映射的方法。</p></li><li><p>变换流</p><ul><li>信息沿输入通路进入系统，同时由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。</li><li>变换型结构的数据流图基本上呈线性形状</li><li>明显地分为输入、变换（或加工）和输出三部分</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/edc698725d186c764731f3103838ef50.png"></li></ul></li><li><p>事务流</p><ul><li><p>系统的数据流图呈辐射状</p></li><li><p>数据沿输入通路到达一个处理T，T根据输入数据的类型，在若干个动作序列中选出一个来执行。处理T称为事务中心，它完成下述任务：</p><ul><li>接收输入数据；</li><li>分析每个事务以确定它的类型；</li><li>根据事务类型选取一条活动通路。</li></ul></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/77f0c879dbf7cb9b363e1afd03ed0905.png"></p></li></ul></li></ul><h3 id="变换分析"><a href="#变换分析" class="headerlink" title="变换分析"></a>变换分析</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/05fa843f556433f25aef387a30735859.png"></li><li>第1步 复查基本系统模型</li><li>第2步 复查并精化数据流图</li><li>第3步 确定数据流的类型</li><li>第4步 确定输入流和输出流边界，从而孤立出变换中心</li><li>第5步 把数据流图映射成系统模块结构，即设计系统的上层模块结构</li><li>第6步  基于数据流图逐步分解高层模块结构，设计出下层模块</li><li>第7步  根据模块独立性原理，精化模块结构</li><li>第8步  描述模块接口信息，给出进出模块的数据信息</li></ul><h3 id="事务分析"><a href="#事务分析" class="headerlink" title="事务分析"></a>事务分析</h3><ul><li><p>虽然在任何情况下都可以使用变换分析方法设计软件结构，但是在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。</p></li><li><p>事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同：</p><ul><li>由事务流映射成的软件结构包括一个接收分支和一个发送分支；</li><li>映射出接收分支结构的方法和变换分析映射出输入结构的方法很相像，即从事务中心的边界开始，把沿着接收流通路的处理映射成模块；</li><li>发送分支的结构包含一个调度模块，它控制下层的所有活动模块；然后把数据流图中的每个活动流通路映射成与它的流特征相对应的结构。 </li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/17/3fb92a6a33043b28752c52efc720414e.png"></li></ul></li></ul><h3 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h3><ul><li>(1) 在不考虑时间因素的前提下开发并精化软件结构</li><li>(2) 在详细设计阶段选出最耗费时间的那些模块，仔细地设计它们的处理过程，以求提高效率</li><li>(3) 使用高级程序设计语言编写程序</li><li>(4) 在软件中孤立出那些大量占用处理机资源的模块</li><li>(5) 必要时重新设计或用依赖于机器的语言重写上述大量占用资源的模块的代码，以求提高效率</li><li>一句格言：“先使它能工作，然后再使它快起来。”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 期中复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第三章</title>
      <link href="2020/11/15/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>2020/11/15/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="3需求分析"><a href="#3需求分析" class="headerlink" title="3需求分析"></a>3需求分析</h1><h2 id="3-1需求分析的任务"><a href="#3-1需求分析的任务" class="headerlink" title="3.1需求分析的任务"></a>3.1需求分析的任务</h2><h3 id="3-1-1确定对系统的综合要求"><a href="#3-1-1确定对系统的综合要求" class="headerlink" title="3.1.1确定对系统的综合要求"></a>3.1.1确定对系统的综合要求</h3><ul><li><p>1.确定系统的功能要求</p><ul><li>提出系统必须完成的全部所有功能</li></ul></li><li><p>2.确定系统的性能要求</p><ul><li>性能需求指定系统必须满足的定时约束或容量约束</li><li>（1）系统的响应时间</li><li>（2）系统需要的存储容量</li><li>（3）后援存储器容量、系统重新启动</li><li>（4）系统的安全性和可靠性</li></ul></li><li><p>3.确定系统的运行要求</p><ul><li>（1）支持系统运行的软件环境</li><li>（2）工具软件和系统软件</li><li>（3）支持系统运行的硬件环境</li><li>（4）出错处理、通信接口、约束</li></ul></li><li><p>4.确定系统的扩充要求</p></li></ul><h3 id="3-1-2分析系统的数据要求"><a href="#3-1-2分析系统的数据要求" class="headerlink" title="3.1.2分析系统的数据要求"></a>3.1.2分析系统的数据要求</h3><ul><li>建立数据模型：数据字典、层次方框图、Warnier图 。</li></ul><h3 id="3-1-3导出系统的逻辑模型"><a href="#3-1-3导出系统的逻辑模型" class="headerlink" title="3.1.3导出系统的逻辑模型"></a>3.1.3导出系统的逻辑模型</h3><ul><li>用数据流图、实体一联系图、状态转换图、数据字典和主要的处理算法导出系统的详细的逻辑模型。</li></ul><h3 id="需求分析的过程"><a href="#需求分析的过程" class="headerlink" title="需求分析的过程"></a>需求分析的过程</h3><ul><li><p>（1）调查研究</p><ul><li>目的：通过各种途径获取用户需求信息产生《用户需求说明书 》</li><li>角色与职责：需求分析员调查、分析用户的需求，客户与最终用户提供必要需求信息</li></ul></li><li><p>（2）分析与综合</p><ul><li>从信息流和信息结构出发，逐步细化所有的软件功能，找出系统各元素之间的联系、接口特性和设计上的约束，分析它们是否满足功能要求。</li></ul></li><li><p>（3）书写需求分析文档</p><ul><li>软件需求说明书</li><li>数据要求说明书</li><li>初步的用户手册</li><li>修改、完善与确定软件开发实施计划</li></ul></li><li><p>（4）需求分析的评审</p><ul><li>系统定义的目标是否与用户的要求一致</li><li>系统需求分析阶段提供的文档资料是否齐全</li><li>文档中的所有描述是否完整、清晰、准确反应用户要求</li><li>与所有其它系统成分的重要接口是否都已经描述</li></ul></li></ul><h3 id="3-1-4修正系统开发计划"><a href="#3-1-4修正系统开发计划" class="headerlink" title="3.1.4修正系统开发计划"></a>3.1.4修正系统开发计划</h3><ul><li>根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。</li></ul><h2 id="3-2与用户沟通获取需求的方法"><a href="#3-2与用户沟通获取需求的方法" class="headerlink" title="3.2与用户沟通获取需求的方法"></a>3.2与用户沟通获取需求的方法</h2><h3 id="3-2-1需求获取"><a href="#3-2-1需求获取" class="headerlink" title="3.2.1需求获取"></a>3.2.1需求获取</h3><ul><li><p>需求获取是在问题及其最终解决方案之间架设桥梁的第一步。</p></li><li><p>需求获取的目的是清楚地理解所要解决的问题，完整地获得用户的需求。</p></li><li><p>获取需求的一个必不可少的结果是对项目中描述的客户需求的普遍理解。一旦理解了需求，分析者、开发者和客户就能探索出描述这些需求的多种解决方案。</p></li><li><p>需求获取活动</p><ul><li><p>（1）发现和分析问题  发现问题症结，并分析问题的原因/结果关系。</p></li><li><p>（2）获取需求  根据对问题的理解定义需求。</p><ul><li>a.使用调查研究方法收集信息；</li><li>b.遵循需求获取框架，按照三个成分观察：即数据、过程和接口。</li></ul></li><li><p>（3）需求归档  以草稿形式归档调查结果。形式有用例、决策表、需求表等</p></li></ul></li></ul><h3 id="3-2-2访谈"><a href="#3-2-2访谈" class="headerlink" title="3.2.2访谈"></a>3.2.2访谈</h3><ul><li><p>非正式访谈— 分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法。</p></li><li><p>正式访谈将根据一些事先准备好的议题全面展开讨论，得出结论性的意见。</p></li><li><p>当需要调查大量人员的意见时，向被调查人分发调查表是一个十分有效的做法。</p></li><li><p>在访问用户的过程中使用情景分析技术往往非常有效</p></li><li><p>情景分析技术的用处</p><ul><li>(1) 它能在某种程度上演示目标系统的行为，从而便于用户理解，而且还可能进一步揭示出一些分析员目前还不知道的需求。</li><li>(2) 由于情景分析较易为用户所理解，使用这种技术能保证用户在需求分析过程中始终扮演一个积极主动的角色。需求分析的目标是获知用户的真实需求，而这一信息的惟一来源是用户，因此，让用户起积极主动的作用对需求分析工作获得成功是至关重要的。</li></ul></li></ul><h3 id="3-2-3面向数据流自顶向下求精"><a href="#3-2-3面向数据流自顶向下求精" class="headerlink" title="3.2.3面向数据流自顶向下求精"></a>3.2.3面向数据流自顶向下求精</h3><ul><li><p>通过可行性研究已经得出了目标系统的高层数据流图，需求分析的目标之一就是把数据流和数据存储定义到元素级。</p><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/c21b31210a2aeb97065e218ce3b1649b.png"></li></ul></li><li><p>结构化分析方法（SA）</p><ul><li>“数据流图”描述系统的分解，即描述系统由哪些部分组成，每个部分之间有什么样的联系等；</li><li>“数据字典”描述系统中的每一个数据；</li><li>“小说明”详细描述系统中的每一个加工；</li><li>“补充材料”是根据需要对系统的补充。</li><li>以上就可以明确而完整地描述一个系统的功能</li></ul></li></ul><h3 id="3-3-4快速建立软件模型"><a href="#3-3-4快速建立软件模型" class="headerlink" title="3.3.4快速建立软件模型"></a>3.3.4快速建立软件模型</h3><ul><li><p>基本思想</p><ul><li>在很短的时间内建立起一个只包含基本数据库和一些基本功能的原型给用户使用，然后根据用户意见对原型进行修改，直到满意为止。</li></ul></li><li><p>快速构建和修改原型，通常使用的3种方法和工具</p><ul><li><p>(1)第四代技术</p><ul><li>包括众多数据库查询和报表语言、程序和应用系统生成器以及其他非常高级的非过程语言。能快速生成可执行的代码。 </li></ul></li><li><p>(2)可重用的软件构件</p><ul><li>使用一组已有的软件构件（也称为组件）来装配（而不是从头构造）原型。 </li></ul></li><li><p>(3)形式化规格说明和原型环境</p><ul><li>在交互式环境下，用自动工具把基于形式语言的规格说明翻译成可执行的程序代码。</li></ul></li></ul></li></ul><h2 id="3-3分析建模与规格说明"><a href="#3-3分析建模与规格说明" class="headerlink" title="3.3分析建模与规格说明"></a>3.3分析建模与规格说明</h2><h3 id="什么是模型？"><a href="#什么是模型？" class="headerlink" title="什么是模型？"></a>什么是模型？</h3><ul><li>为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。</li><li>模型通常由一组图形符号和组织这些符号的规则组成。</li></ul><h3 id="模型的作用"><a href="#模型的作用" class="headerlink" title="模型的作用"></a>模型的作用</h3><ul><li>在建模过程中了解系统</li><li>通过抽象降低复杂性</li><li>有助于回忆所有的细节</li><li>有助于开发小组间的交流</li><li>有助于与用户的交流</li><li>为系统的维护提供文档</li></ul><h3 id="结构化分析（-Structured-Analysis-SA-）"><a href="#结构化分析（-Structured-Analysis-SA-）" class="headerlink" title="结构化分析（ Structured Analysis , SA ）"></a>结构化分析（ Structured Analysis , SA ）</h3><ul><li><p>是面向数据流进行分析的方法，主要建立以下几种模型：</p><ul><li>实体关系图(Entity-Relationship Diagram,E-R图)来创建数据模型，描述系统中所有重要的数据对象；</li><li>数据流图（Data Flow Diagram,DFD） ：用来创建功能模型，描述了信息流和数据转换。</li><li>状态转换图 （State-Transition Diagram,STD）用来创建行为模型，描述系统状态如何响应外部事件，而进行转换。</li></ul></li></ul><h3 id="面向对象分析方法建立的模型"><a href="#面向对象分析方法建立的模型" class="headerlink" title="面向对象分析方法建立的模型"></a>面向对象分析方法建立的模型</h3><ul><li>对象模型(Object model)：定义实体，描述系统的静态结构，定义“对谁做”</li><li>动态模型(Dynamic model):描述对象之间的交互过程，规定“何时做”</li><li>功能模型 (Functional model) ：描述内部数据的处理，指明系统应“做什么”</li></ul><h2 id="3-4实体-联系图"><a href="#3-4实体-联系图" class="headerlink" title="3.4实体-联系图"></a>3.4实体-联系图</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><ul><li>ER图 —- 是用来建立数据模型的工具。</li><li>数据模型 —- 是一种面向问题的数据模型，是按照用户的观点对数据建立的模型。它描述了从用户角度看到的数据，反映了用户的现实环境，而且与在软件系统中的实现方法无关。</li><li>数据模型中包含3种相互关联的信息：数据对象（实体）、数据对象的属性及数据对象彼此间相互连接的关系。</li></ul><h3 id="1-数据对象-实体"><a href="#1-数据对象-实体" class="headerlink" title="1.数据对象(实体)"></a>1.数据对象(实体)</h3><ul><li>数据对象:是信息世界中描述客观事物的概念。</li><li>可以由一组属性来定义的实体都可以被认为是数据对象。</li><li>如：外部实体、事物、行为、事件、角色、单位、地点或结构等。</li><li>数据对象彼此间是有关联的。</li></ul><h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h3><ul><li>属性定义了数据对象的性质。</li><li>必须把一个或多个属性定义为“标识符”，也就是说，当我们希望找到数据对象的一个实例时，用标识符属性作为“关键字”(通常简称为“键”)。</li><li>应该根据对所要解决的问题的理解，来确定特定数据对象的一组合适的属性。</li><li>如：学生具有学号、姓名、性别、年龄、专业等属性；</li><li>课程具有课程号、课程名、学分、学时数等属性；</li><li>教师具有职工号、姓名、年龄、职称等属性。</li></ul><h3 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h3><ul><li>a.  一对一联系(1∶1)</li><li>b.  一对多联系(1∶N)</li><li>c. 多对多联系(M∶N)</li></ul><h3 id="实体-联系图的符号"><a href="#实体-联系图的符号" class="headerlink" title="实体-联系图的符号"></a>实体-联系图的符号</h3><ul><li>ER图中包含了实体(即数据对象)、关系和属性等3种基本成分。</li><li>通常用矩形框代表实体；</li><li>用连接相关实体的菱形框表示关系；</li><li>用椭圆形表示实体(或关系)的属性；</li><li>并用直线把实体(或关系)与其属性连接起来。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/31fa1ba0abb172e73fe030e5433bd4fa.png"></li></ul><h2 id="3-5数据规范化"><a href="#3-5数据规范化" class="headerlink" title="3.5数据规范化"></a>3.5数据规范化</h2><h3 id="数据规范化的目的"><a href="#数据规范化的目的" class="headerlink" title="数据规范化的目的"></a>数据规范化的目的</h3><ul><li>（1）消除数据冗余，即消除表格中数据的重复；</li><li>（2）消除多义性，使关系中的属性含义清楚、单一；</li><li>（3）使关系的“概念”单一化，让每个数据项只是一个简单的数或字符串，而不是一个组项或重复组；</li><li>（4）方便操作。使数据的插入、删除与修改操作可行并方便；</li><li>（5）使关系模式更灵活，易于实现接近自然语言的查询方式。</li></ul><h3 id="3种范式"><a href="#3种范式" class="headerlink" title="3种范式"></a>3种范式</h3><ul><li>第一范式：每个属性值都必须是原子值，即仅仅是一个简单值而不含内部结构。</li><li>第二范式：满足第一范式条件，而且每个非关键字属性都由整个关键字决定(而不是由关键字的一部分来决定)。</li><li>第三范式：符合第二范式的条件，每个非关键字属性都仅由关键字决定，而且一个非关键字属性不能仅仅是对另一个非关键字属性的进一步描述(即一个非关键字属性值不依赖于另一个非关键字属性值)。</li></ul><h2 id="3-6状态转换图"><a href="#3-6状态转换图" class="headerlink" title="3.6状态转换图"></a>3.6状态转换图</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。此外，状态图还指明了作为特定事件的结果系统将做哪些动作(例如，处理数据)。</li></ul><h3 id="（1）状态"><a href="#（1）状态" class="headerlink" title="（1）状态"></a>（1）状态</h3><ul><li>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。系统对事件的响应，既可以是做一个(或一系列)动作，也可以是仅仅改变系统本身的状态，还可以是既改变状态又做动作。</li></ul><h3 id="（2）事件"><a href="#（2）事件" class="headerlink" title="（2）事件"></a>（2）事件</h3><ul><li>事件是在某个特定时刻发生的事情，它是对引起系统做动作或(和)从一个状态转换到另一个状态的外界事件的抽象。</li><li>例如，内部时钟表明某个规定的时间段已经过去，用户移动或点击鼠标等都是事件。</li><li>简而言之，事件就是引起系统做动作或(和)转换状态的控制信息。</li></ul><h3 id="（3）符号"><a href="#（3）符号" class="headerlink" title="（3）符号"></a>（3）符号</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/4b7c134dddd7d0d8018b27da370f4292.png"></li></ul><h3 id="（4）例子（见书本）"><a href="#（4）例子（见书本）" class="headerlink" title="（4）例子（见书本）"></a>（4）例子（见书本）</h3><h2 id="3-7其他图形工具"><a href="#3-7其他图形工具" class="headerlink" title="3.7其他图形工具"></a>3.7其他图形工具</h2><h3 id="3-7-1-层次方框图"><a href="#3-7-1-层次方框图" class="headerlink" title="3.7.1  层次方框图"></a>3.7.1  层次方框图</h3><ul><li>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。</li><li>树形结构的顶层是一个单独的矩形框，它代表完整的数据结构，下面的各层矩形框代表这个数据的子集，最底层的各个框代表组成这个数据的实际数据元素(不能再分割的元素)。</li><li>随着结构的精细化，层次方框图对数据结构也描绘得越来越详细，这种模式非常适合于需求分析阶段的需要。系统分析员从对顶层信息的分类开始，沿图中每条路径反复细化，直到确定了数据结构的全部细节时为止。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/ca1550bdfed0ff95e7a00a50a4a27a6f.png"></li></ul><h3 id="3-7-2-Warnier图"><a href="#3-7-2-Warnier图" class="headerlink" title="3.7.2  Warnier图"></a>3.7.2  Warnier图</h3><ul><li>法国计算机科学家Warnier提出了表示信息层次结构的另外一种图形工具。</li><li>Warnier图也用树形结构描绘信息，但是这种图形工具比层次方框图提供了更丰富的描绘手段。</li><li>用Warnier图可以表明信息的逻辑组织。它可以指出一类信息或一个信息元素是重复出现的，也可以表示特定信息在某一类信息中是有条件地出现的。</li><li>重复和条件约束是说明软件处理过程的基础，所以很容易把Warnier图转变成软件设计的工具。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/ece2d4657c23106a44ee04ee61ce9170.png"></li><li>图中表示一种软件产品要么是系统软件要么是应用软件。系统软件中有P1种操作系统，P2种编译程序，此外还有软件工具。软件工具是系统软件的一种，它又可以进一步细分为编辑程序、测试驱动程序和设计辅助工具，图中标出了每种软件工具的数量。</li></ul><h3 id="3-7-2-IPO图"><a href="#3-7-2-IPO图" class="headerlink" title="3.7.2  IPO图"></a>3.7.2  IPO图</h3><ul><li>IPO图是输入、处理、输出图的简称，它是美国IBM公司发展完善起来的一种图形工具</li><li>描述输入数据、处理数据和输出数据</li><li>在需求分析阶段使用IPO图简略的描述系统的主要算法</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/8a5d9a75f839f8e9b47fbbbe9d55e86b.png"></li><li>左边的框中列出有关的输入数据。</li><li>中间的框内列出主要的处理，处理框中列出处理的次序暗示了执行的顺序，但是用这些基本符号还不足以精确描述执行处理的详细情况。</li><li>在右边的框内列出产生的输出数据。</li><li>在IPO图中还用类似向量符号的粗大箭头清楚地指出数据通信的情况。</li></ul><h3 id="3-7-3-改进的IPO图-也称为IPO表"><a href="#3-7-3-改进的IPO图-也称为IPO表" class="headerlink" title="3.7.3   改进的IPO图(也称为IPO表)"></a>3.7.3   改进的IPO图(也称为IPO表)</h3><ul><li>在需求分析阶段可以使用IPO表简略地描述系统的主要算法(即数据流图中各个处理的基本算法)。</li><li>需求分析阶段，IPO表中的许多附加信息暂时还不具备，但在设计阶段可以进一步补充修正这些图，作为设计阶段的文档。</li><li>这正是在需求分析阶段用IPO表作为描述算法的工具的重要优点。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/15/8a9843255e53acda262a4d4c129ca72c.png"></li><li>在需求分析阶段可以使用IPO表简略地描述系统的主要算法(即数据流图中各个处理的基本算法)。</li><li>需求分析阶段，IPO表中的许多附加信息暂时还不具备，但在设计阶段可以进一步补充修正这些图，作为设计阶段的文档。</li><li>这正是在需求分析阶段用IPO表作为描述算法的工具的重要优点</li></ul><h2 id="3-8验证软件需求"><a href="#3-8验证软件需求" class="headerlink" title="3.8验证软件需求"></a>3.8验证软件需求</h2><h3 id="一、验证软件需求的正确性"><a href="#一、验证软件需求的正确性" class="headerlink" title="一、验证软件需求的正确性"></a>一、验证软件需求的正确性</h3><ul><li>(1) 一致性   所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。</li><li>(2) 完整性  需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。</li><li>(3) 现实性  指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。</li><li>(4) 有效性  必须证明需求是正确有效的，确实能解决用户面对的问题。</li></ul><h3 id="二、验证软件需求的方法"><a href="#二、验证软件需求的方法" class="headerlink" title="二、验证软件需求的方法"></a>二、验证软件需求的方法</h3><ul><li><p>1、验证需求的一致性</p><ul><li><pre><code>人工技术：需求分析的结果是用自然语言书写</code></pre></li><li><pre><code>软件工具:  软件需求规格说明书是用形式化的需求陈述语言书写</code></pre></li></ul></li><li><p>2、验证需求的现实性</p><ul><li><pre><code>分析员应该参照以往开发类似系统的经验，分析用现有的软、硬件技术实现目标系统的可能性。必要的时候应该采用仿真或性能模拟技术，辅助分析软件需求规格说明书的现实性。</code></pre></li></ul></li><li><p>3、验证需求的完整性和有效性</p><ul><li><pre><code>使用原型系统，而不去开发实际系统，这样做可以节约成本和时间，其目的是显示目标系统的主要功能，而不是性能。</code></pre></li></ul></li></ul><h3 id="三、用于需求分析的软件工具"><a href="#三、用于需求分析的软件工具" class="headerlink" title="三、用于需求分析的软件工具"></a>三、用于需求分析的软件工具</h3><ul><li>RSL（需求陈述语言）</li><li>PSL/PSA （问题陈述语言/问题陈述分析程序）</li></ul><h2 id="3-9需求分析步骤总结"><a href="#3-9需求分析步骤总结" class="headerlink" title="3.9需求分析步骤总结"></a>3.9需求分析步骤总结</h2><ul><li><p>⑴ 问题描述</p></li><li><p>⑵ 画分层的数据流图</p></li><li><p>⑶ 决定哪些部分需要计算机化和怎样计算机化</p></li><li><p>⑷ 数据细节描述</p></li><li><p>⑸ 定义处理逻辑</p></li><li><p>⑹ 定义物理资源</p></li><li><p>⑺ 确定输入/输出规格说明，确定有关数值</p></li><li><p>⑻ 确定硬件需求</p></li><li><p>⑼ 根据结构化分析模型，建立系统规格说明文档</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 期中复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第二章</title>
      <link href="2020/11/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>2020/11/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="2-可行性研究"><a href="#2-可行性研究" class="headerlink" title="2.可行性研究"></a>2.可行性研究</h1><h2 id="2-1问题定义"><a href="#2-1问题定义" class="headerlink" title="2.1问题定义"></a>2.1问题定义</h2><h3 id="1-问题定义的内容"><a href="#1-问题定义的内容" class="headerlink" title="1.问题定义的内容"></a>1.问题定义的内容</h3><ul><li>（1）问题的背景，弄清楚待开发系统现在处于什么状态，为什么要开发它，是否具备开发条件等问题。</li><li>（2）提出开发系统的问题要求以及总体要求。</li><li>（3）明确问题的性质、类型和范围。</li><li>（4）明确待开发系统要实现的目标、功能和规模。</li><li>（5）提出开发的条件要求和环境要求。</li></ul><h3 id="2-问题定义的方法"><a href="#2-问题定义的方法" class="headerlink" title="2.问题定义的方法"></a>2.问题定义的方法</h3><ul><li>首先，系统分析员要针对用户的要求做详细的调查研究，认真听取用户对问题的介绍；阅读与问题有关的资料，必要时还要深入现场，亲自操作；调查开发系统的背景;了解用户对开发的要求。</li><li>其次，是与用户反复讨论，以使问题进一步确定化。经过用户和系统分析员双方充分协商，确定问题定义的内容。</li><li>最后，写出双方均认可的问题定义报告。</li></ul><h2 id="2-2可行性研究的目的和任务"><a href="#2-2可行性研究的目的和任务" class="headerlink" title="2.2可行性研究的目的和任务"></a>2.2可行性研究的目的和任务</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h3><ul><li>明确问题是否能够解决</li><li>明确问题是否值得去解决</li></ul><h3 id="2-实质"><a href="#2-实质" class="headerlink" title="2.实质"></a>2.实质</h3><ul><li>可行性研究的实质是在高层次上做一次大大简化了的需求分析和设计。是在较高层次上以较抽象的方式进行的系统分析和设计的过程。</li></ul><h3 id="可行性研究应着重考虑的五个方面："><a href="#可行性研究应着重考虑的五个方面：" class="headerlink" title="可行性研究应着重考虑的五个方面："></a>可行性研究应着重考虑的五个方面：</h3><ul><li><p>（1）技术可行性</p><ul><li>主要包括:在给出的限制范围内，能否设计出系统，并实现必要的功能和性能;开发人员、硬件和软件是否存在问题;系统所用到的相关技术是否支持。</li></ul></li><li><p>（2）经济可行性</p><ul><li>经济可行性问题包含两方面：一方面是经济实力；另一方面是经济效益。分析经济可行性研究的内容是要进行开发成本的估算，了解项目成功取得效益的评估，确定要开发的项目是否值得投资开发。</li></ul></li><li><p>（3）运行可行性</p><ul><li>如果新系统建立在原来已担负其他任务的原系统上，就不能要求它在实时在线状态下运行，以免与原有的任务相矛盾。</li></ul></li><li><p>（4）操作可行性</p><ul><li>① 软件能否被有效的使用；</li><li>②开发过程中能否得到用户方的必要支持；</li><li>③软件使用所带来的影响用户方能否接受。</li></ul></li><li><p>（5）法律可行性</p></li></ul><blockquote><p>可行性研究最根本的任务是对以后的行动方向提出建议。如果可行性研究的结果是问题没有可行的解，那么系统分析员应该建议停止这项工程的开发;如果可行性研究的结果是问题值得去解决，那么系统分析员应该推荐一个较好的解决方案，并且为工程制定一个初步的开发计划。</p></blockquote><h2 id="2-3可行性研究过程"><a href="#2-3可行性研究过程" class="headerlink" title="2.3可行性研究过程"></a>2.3可行性研究过程</h2><h3 id="1-可行性研究工作流程"><a href="#1-可行性研究工作流程" class="headerlink" title="1.可行性研究工作流程"></a>1.可行性研究工作流程</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/2e9f836b78e6d90a6684bb66178ca498.png"></li></ul><h3 id="2-可行性研究的方法和步骤"><a href="#2-可行性研究的方法和步骤" class="headerlink" title="2. 可行性研究的方法和步骤"></a>2. 可行性研究的方法和步骤</h3><ul><li><p>（1）复查系统规模和目标</p><ul><li>分析员访问关键人员，仔细阅读和分析有关的材料，对项目的规模和目标进行定义和确认，描述项目的一切限制和约束，以确保分析员提交的报告书确实是用户要求解决的。</li></ul></li><li><p>（2）研究目前正在使用的系统</p><ul><li>现有系统的基本功能是新系统所必须具备的；</li><li>现有系统存在的缺点，新系统必须加以改进；</li><li>现有系统所不具备的功能，又是用户必须的，则新系统一定要预以增加；</li><li>现有系统所需要的费用是新系统的一个重要的投资依据。如果新系统不能增加收入或减少使用费用，那么从经济角度看新系统就不如旧系统。</li></ul></li><li><p>（3）导出新系统的高层逻辑模型</p><ul><li><p>从现有的物理系统出发，导出现有物理系统的逻辑模型；</p></li><li><p>再以现有物理系统的逻辑模型为基础，设计出新系统的高层逻辑模型；</p></li><li><p>最后根据高层逻辑模型建造新的物理系统。</p></li><li><p>3类模型</p><ul><li><p>概念模型</p><ul><li>概念模型就是在了解了用户的需求，用户的业务领域工作情况以后，经过分析和总结，提炼出来的用以描述用户业务需求的一些概念的东西。如销售业务中的“客户”和“定单”，还有就是“商品”，“业务员”。一个用例描述就是：“业务员”与“客户”就购买“商品”之事签定下“定单”。</li></ul></li><li><p>逻辑模型</p><ul><li>逻辑模型就是要将概念模型具体化。要实现概念模型所描述的东西，需要哪些具体的功能和处理哪些具体的信息。这就到了需求分析的细化阶段。仍以销售业务为例：“客户”信息基本上要包括：单位名称，联系人，联系电话，地址等属性；“商品”信息基本上要包括：名称，类型，规 格，单价等属性；“定单”信息基本上要包括：日期和时间属性。并且“定单”要与“客户”，“业务员”和“商品”明细关联。  </li></ul></li><li><p>物理模型</p><ul><li>物理模型就是针对上述逻辑模型所说的内容，在具体的物理介质上实现出来。如：数据库使用SQL Server 2000，这样就可以编写具体的SQL脚本在数据库服务器上将数据库建立起来。其中包括业务员信息表，客户信息表，商品信息表，定单表。客户端使用VS开发工具，那么在工作站上用VS建立起功能菜单，包括：业务员信息维护，客户信息维护，商品信息维护，建立销售定单等功能，并用工具将每一个功能编码实现。</li></ul></li></ul></li></ul></li><li><p>（4）进一步定义问题 </p><ul><li>定义系统目标 —&gt; 复查系统目标和规模 —&gt; 研究现有系统 —&gt; 设计新系统 —&gt; 再定义系统目标。</li></ul></li><li><p>（5）导出和评价供选择的方案 </p><ul><li> 从技术角度排除那些不现实的方案；</li><li> 从操作角度去掉那些操作方式或操作过程是用户不能接受的方案；</li><li> 从经济角度估算每个可能系统的成本/效益。</li></ul></li><li><p>（6）推荐方案和行动方针 </p><ul><li>本项目的开发价值；</li><li>推荐这个方案的理由；</li><li>制订实现项目的进度表。</li></ul></li><li><p>（7）决策 </p><ul><li>使用部门的负责人根据经济实力及分析员在可行性研究阶段对开发此项工程成本/效益分析情况的分析结论，决定是否继续这项开发工程。</li></ul></li><li><p>（8）草拟开发计划</p><ul><li>工程的进度；</li><li>人才资源（系统分析员、程序员）的需求及使用；</li><li>设备资源的需求及使用（软、硬件工具）、估算生存周期每个阶段的成本；   </li><li>给出下一阶段（需求分析）的详细进度表和成本估计。</li></ul></li><li><p>（9）书写文档提交审查  </p></li></ul><h2 id="2-4系统流程图"><a href="#2-4系统流程图" class="headerlink" title="2.4系统流程图"></a>2.4系统流程图</h2><h3 id="1基本内容"><a href="#1基本内容" class="headerlink" title="1基本内容"></a>1基本内容</h3><ul><li>（1）用图形符号以黑盒子形式描述系统内的每一个成分（例如:程序、文件、数据库、表格、硬件设备、人工过程等）。</li><li>（2）用“→”表示信息在系统各个成分之间的流动情况，不要误认为“　”表示信息的加工和控制过程。因此尽管系统流程图的某些符号和程序流程图的符号形式相同，但是它却是物理数据流图而不是程序流程图。</li></ul><h3 id="2符号"><a href="#2符号" class="headerlink" title="2符号"></a>2符号</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/11d455c205975352c3603f0cc66b9fc5.png"></li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/f7f5fcbdf42b26d2930a1a10891714bb.png"></li></ul><h3 id="3例子（见书本）"><a href="#3例子（见书本）" class="headerlink" title="3例子（见书本）"></a>3例子（见书本）</h3><h3 id="4分层"><a href="#4分层" class="headerlink" title="4分层"></a>4分层</h3><ul><li>面对复杂的系统时，一个比较好的方法是分层次地描绘这个系统。首先用一张高层次的系统流程图描绘系统总体概貌，表明系统的关键功能。然后分别把每个关键功能扩展到适当的详细程度，画在单独的一页纸上。这种分层次的描绘方法便于阅读者按从抽象到具体的过程逐步深入地了解一个复杂的系统。</li></ul><h2 id="2-5数据流图"><a href="#2-5数据流图" class="headerlink" title="2.5数据流图"></a>2.5数据流图</h2><h3 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="1.基本内容"></a>1.基本内容</h3><ul><li><p>数据流图（DFD）是描述数据处理过程的工具。它从数据传递和加工的角度，以图形的方式描述数据流从输入到输出的传输变换过程。</p><ul><li>一种图形化技术，一种描述“分解”的图示工具</li><li>表示信息和数据从输入到输出所经受的变换</li><li>描述数据在系统中流动和被处理的逻辑过程</li><li>没有任何具体的物理部件</li></ul></li></ul><h3 id="2-符号"><a href="#2-符号" class="headerlink" title="2.符号"></a>2.符号</h3><ul><li>（1）“→”表示数据和数据流。箭头表示数据的流动方向。数据流图中应在线旁标注数据流名。</li><li>（2）“○”表示对数据的加工，即对数据的某种操作或变换。数据流图中应在圆圈内写上加工名。</li><li>（3）“     ”表示按照某种规则生成，且长度不限的数据文件（也称数据存储）。数据流图中应在双线旁标注文件名。</li><li>（4）“□”表示数据流的源头和终端。</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/e354e92a7038ff0d6e5864c85e3aef9d.png"></li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/aea8fc2409fd1510c5d2ec7a74a79423.png"></li></ul><h3 id="3-例子（见书本）"><a href="#3-例子（见书本）" class="headerlink" title="3.例子（见书本）"></a>3.例子（见书本）</h3><h3 id="4-命名"><a href="#4-命名" class="headerlink" title="4.命名"></a>4.命名</h3><ul><li><p>数据流(或数据存储)</p><ul><li>（1）名字应代表整个数据流(或数据存储)的内容，而不是仅仅反映它的某些成分。</li><li>（2） 不要使用空洞的、缺乏具体含义的名字(如“数据”、“信息”、“输入”之类)。</li><li>（3） 如果在为某个数据流(或数据存储)起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成的，应该试试重新分解，看是否能克服这个困难。</li><li>（4）两个加工之间可以有多个数据流，这些数据流之间没有任何联系。在加工之间传输的数据流必须有一个合适的名词，而在文件和加工之间传输的数据流可以不命名，因为可以从“加工”和“文件”的名字，弄清数据流的含义</li></ul></li><li><p>处理</p><ul><li>(1) 通常先为数据流命名，然后再为与之相关联的处理命名。</li><li>(2) 名字应该反映整个处理的功能，而不是它的一部分功能。  不要使用含糊不具体的动词，如“处理”、“加工”等。 </li><li>(3) 名字最好由一个具体的及物动词加上一个具体的宾语组成。</li><li>(4) 通常名字中仅包括一个动词，如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。</li><li>(5) 如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的迹象，应考虑重新分解。</li></ul></li><li><p>数据源头和终点</p><ul><li>数据源头和终点是数据的始发点和终止点，是表示系统和环境的接口。在实际问题中，它可以是人员、计算机外部设备或其他装置，不需要对它进行软件设计和实现。因此，在命名时应符合环境的真实状况.</li></ul></li></ul><h3 id="5-优点"><a href="#5-优点" class="headerlink" title="5.优点"></a>5.优点</h3><ul><li>DFD用一种直接而又直观的方法来描述数据的流动和信息系统中的操作。首先，它使用客观图像描述了用户的需求，不带有任何个人或组织的说法或观点。其次，数据流图形象真实，便于用户理解和接受，同时也便于系统分析员之间交流信息。最后，数据流图采用自顶向下分解的多层次图形具有一定的抽象性，而且数据流图不强调控制流，突出数据流，便于找到主要矛盾，省略次要细节，从而减少系统的复杂性。</li></ul><h3 id="6-缺点"><a href="#6-缺点" class="headerlink" title="6.缺点"></a>6.缺点</h3><ul><li>DFD图形符号也存在着一定的缺点。首先，数据流图对时间、界面等方面的内容无法表达。其次，DFD只能做出粗略的模型，而如果需要更精确、更详细的说明时，DFD无法做到。</li></ul><h3 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h3><ul><li>1、作为信息交流的工具分析员把他对现有系统的认识或对目标系统的设想用数据流图描绘出来，供有关人员审查确认。</li><li>2、作为分析和设计的工具</li><li>3、数据流图可以辅助物理系统的设计（图）根据不同要求，能够在数据流图上画出许多组自动化边界，每组自动化边界可能意味着一个不同的物理系统，因此可以根据系统的逻辑模型考虑系统的物理实现。</li><li>4、数据流图对详细设计也有帮助。</li></ul><h2 id="2-6数据字典"><a href="#2-6数据字典" class="headerlink" title="2.6数据字典"></a>2.6数据字典</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><ul><li>数据字典是关于数据信息的集合。数据字典定义数据流图中所有元素（包括数据流、数据流的组成、文件及其它应进入数据字典的一切数据）。</li></ul><h3 id="2-与数据流图的联系"><a href="#2-与数据流图的联系" class="headerlink" title="2.与数据流图的联系"></a>2.与数据流图的联系</h3><ul><li>数据字典中所有名字的定义就够成了一本字典与数据流图共同构成系统的逻辑模型</li></ul><h3 id="3-数据字典的内容"><a href="#3-数据字典的内容" class="headerlink" title="3. 数据字典的内容"></a>3. 数据字典的内容</h3><p>分别对DFD中元素的定义：</p><ul><li><p>  数据流</p></li><li><p>数据流分量（即数据元素）</p><ul><li>   名字、别名、描述、数据类型、长度、结构、值的范围、使用方式、控制信息、分组信息等</li></ul></li><li><p>  数据存储</p></li><li><p>  处理 （结合IPO图或PDL ） </p></li></ul><h3 id="4-定义数据的方法"><a href="#4-定义数据的方法" class="headerlink" title="4.定义数据的方法"></a>4.定义数据的方法</h3><ul><li><p>组成数据的方式</p><ul><li>1）顺序 —— 以确定次序连接两个或多个分量</li><li>2）选择 —— 从两个或多个可能的元素中选取一个</li><li>3）重复 —— 把指定的分量重复零次或多次</li><li>4）可选 —— 一个分量是可有可无的</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/3f459c830d62cce83905c0aa809bdc38.png"></li></ul></li></ul><h3 id="5-用途"><a href="#5-用途" class="headerlink" title="5. 用途"></a>5. 用途</h3><ul><li>作为分析阶段的工具</li><li>能单独处理描述每个数据元素的信息</li><li>是开发数据库的第一步（基础 关键）</li></ul><h3 id="6-数据字典的实现"><a href="#6-数据字典的实现" class="headerlink" title="6.数据字典的实现"></a>6.数据字典的实现</h3><ul><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/0d45fe53cf8b1bcae4770ea94502950d.png"></li></ul><h2 id="2-7成本-效益分析"><a href="#2-7成本-效益分析" class="headerlink" title="2.7成本/效益分析"></a>2.7成本/效益分析</h2><h3 id="1-成本估计："><a href="#1-成本估计：" class="headerlink" title="1.成本估计："></a>1.成本估计：</h3><ul><li><p>（1）代码行技术（LOC技术）</p><ul><li>1）确定功能：把项目功能反复分解到足够细，直到可以对为实现该功能所需要的源代码行数作出可靠的估算为止。</li><li>2）算出各子功能代码行数的平均值：首先根据经验和历史数据对每个子功能估计其程序规模的大小，即最小规模a，最大规模b和最可能的规模m，然后用下式计算该子功能的源代码行数的平均值Le:</li><li><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/xingjiahui/CDN@latest/2020/11/14/2efb453bdca27476a11dbe9c6a14a320.png"></li><li>3） 确定各子功能的代码行成本和生产率：</li><li>4） 计算各子功能的成本和人力（工作量）</li><li>5）计算该项目的总代码行数、总成本和总工作量。</li></ul></li><li><p>（2）任务分解技术</p><ul><li>工程分解为若干个相对独立的任务 - 按阶段划分 - 按子系统划分</li><li>分别估计每个单独的开发任务的成本 -  每个任务的成本  =  耗费人力(人月)*人月平均工资</li><li>累加得到工程的总成本</li></ul></li><li><p>（3）自动估计成本技术</p><ul><li>采用自动估计成本的软件工具</li><li>长期搜集的大量历史数据为基础</li><li>有良好的数据库系统支持</li></ul></li></ul><h3 id="2-成本-效益分析方法"><a href="#2-成本-效益分析方法" class="headerlink" title="2.成本/效益分析方法"></a>2.成本/效益分析方法</h3><ul><li><p>基本内容</p><ul><li>估计开发成本、运行费用和新系统将带来的经济效益</li><li>运行费用取决于系统的操作费用(人员数、工作时间、损耗等)和维护费用</li><li>系统的经济效益等于因使用新系统而增加的收入加上使用新系统可以节省的运行费用。</li><li>总的效益和估计的软件寿命有关。</li></ul></li><li><p>四个重要的概念：</p><ul><li><p>货币的时间价值 </p><ul><li>比较新系统的开发成本（当前）和经济效益（未来）</li><li>用利率的形式表示货币的时间价值。</li></ul></li><li><p>纯收入</p><ul><li>在整个生命周期之内系统的累计经济效益(折合成现在值)与投资之差。</li></ul></li><li><p>投资回收期</p><ul><li>用来衡量一项开发工程的价值</li><li>是使累计的经济效益等于最初投资所需要的时间</li><li>投资回收期越短就能越快获得利润，也就越值得投资。</li><li>是一项经济指标</li></ul></li><li><p>投资回收率</p><ul><li>衡量投资效益的大小</li><li>通常和年利率相比较，衡量经济效益</li></ul></li></ul></li></ul><h2 id="2-8可行性研究报告"><a href="#2-8可行性研究报告" class="headerlink" title="2.8可行性研究报告"></a>2.8可行性研究报告</h2><ul><li><p>1）引言：说明可行性研究的目的，项目的名称、背景，本文档用到的术语和参考资料。</p></li><li><p>2）可行性研究的前提：说明待开发项目的功能、性能和基本要求，要达到的目标，各种约束条件，可行性研究的方法和决定可行性的主要因素。</p></li><li><p>3）对现行系统的分析：如果有现行系统，说明现行系统的处理流程和数据流程，系统状态，费用支出，所需专业人员的种类和数量，所需设备，存在的问题等。</p></li><li><p>4）方案选择：所选择方案的系统配置，选择方案的标准。</p></li><li><p>5）技术可行性分析：对所选择的较好的方案的风险分析、资源分析和技术分析；对子系统的技术分析。</p></li><li><p>6）经济可行性分析：说明所建议系统的成本-效益分析结果。</p></li><li><p>7）运行、操作可行性分析。</p></li><li><p>8）法律可行性分析。</p></li><li><p>9）其他可供选择方案：分别说明每一个可供选择的方   案，并应说明未被推荐的理由。</p></li><li><p>10）结论意见：说明项目是否能开发，还需要什么条件才能开发以及对项目目标有何变动等。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 期中复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程第一章</title>
      <link href="2020/11/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>2020/11/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-软件工程学概述"><a href="#1-软件工程学概述" class="headerlink" title="1.软件工程学概述"></a>1.软件工程学概述</h1><h2 id="1-1软件危机"><a href="#1-1软件危机" class="headerlink" title="1.1软件危机"></a>1.1软件危机</h2><h3 id="1-1-1软件危机的介绍"><a href="#1-1-1软件危机的介绍" class="headerlink" title="1.1.1软件危机的介绍"></a>1.1.1软件危机的介绍</h3><ul><li>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题</li><li>软件危机包含两方面的问题：如何开发软件，以满足对软件日益增长的需求，如何维护数量不断膨胀的已有软件。</li></ul><h3 id="1-1-2产生软件危机的原因"><a href="#1-1-2产生软件危机的原因" class="headerlink" title="1.1.2产生软件危机的原因"></a>1.1.2产生软件危机的原因</h3><ul><li><p>客观原因：由软件本身的特点决定</p><ul><li>   软件是手工劳动，是智力产品—-生产率低。</li><li>   软件是逻辑实体，出错容易，纠错困难。</li><li>   软件的复杂性使得仅靠人的智力难以驾驭。</li></ul></li><li><p>主观原因：</p><ul><li>开发方式：认为开发软件就是写程序。</li><li>组织方式：作坊式的生产方式；开发无计划、开发过程无规范、开发过程难控制。</li><li>用户方面：对软件需求描述不精确。</li><li>开发人员方面：对用户需求的理解与用户本来愿望有差异，相互之间的信息交流不及时、不准确、有误解。</li></ul></li><li><p>软件危机的表现形式</p><ul><li>（1）对软件开发成本和进度的估计常常很不准确。</li><li>（2）用户对“已完成的”软件系统不满意的现象经常发生。</li><li>（3）软件产品的质量往往靠不住。</li><li>（4）软件常常是不可维护的。</li><li>（5）软件通常没有适当的文档资料。</li><li>（6）软件成本在计算机系统总成本所占的比例逐年上升。</li><li>（7）软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势、软件产品“供不应求”的现象使人类不能充分利用现代计算机硬件提供的巨大潜力。</li></ul></li></ul><h3 id="1-1-3消除软件危机的途径"><a href="#1-1-3消除软件危机的途径" class="headerlink" title="1.1.3消除软件危机的途径"></a>1.1.3消除软件危机的途径</h3><ul><li>为了消除软件危机，首先应该对计算机软件有一个正确的认识。</li><li>软件=程序+数据+文档</li><li>1）加快新一代计算机的研制工作；<br>2）应该有组织，有计划，通过严格的管理手段进行软件的开发；<br>3）及时总结软件开发的成功技术和方法并加以推广；<br>4）应该选择好的开发工具进行软件的开发</li></ul><h2 id="1-2软件工程"><a href="#1-2软件工程" class="headerlink" title="1.2软件工程"></a>1.2软件工程</h2><h3 id="1-2-1软件工程的介绍"><a href="#1-2-1软件工程的介绍" class="headerlink" title="1.2.1软件工程的介绍"></a>1.2.1软件工程的介绍</h3><ul><li><p>软件工程是：①把系统的、规范的、可度量的途径应用于软件开发、运行、维护过程，也就是把工程应用于软件；②研究①中提到的途径。</p></li><li><p>软件工程的本质特性</p><ul><li>1.软件工程关注于大型程序的构造</li><li>2.软件工程的中心课题是控制系统复杂性</li><li>3.软件经常变化</li><li>4.开发软件的效率非常重要</li><li>5.和谐的合作是开发软件的关键</li><li>6.软件必须有效地支持它的用户</li><li>7.在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品</li></ul></li></ul><h3 id="1-2-2软件工程的基本原理"><a href="#1-2-2软件工程的基本原理" class="headerlink" title="1.2.2软件工程的基本原理"></a>1.2.2软件工程的基本原理</h3><ul><li>1.用分阶段的生命周期计划严格管理</li><li>2.坚持进行阶段评审</li><li>3.实行严格的产品控制</li><li>4.采用现代程序设计技术</li><li>5.结果应能清楚地审查</li><li>6.开发小组的人员应该少而精</li><li>7.承认不断改进软件工程时间的必要性</li></ul><h3 id="1-2-3软件工程方法学"><a href="#1-2-3软件工程方法学" class="headerlink" title="1.2.3软件工程方法学"></a>1.2.3软件工程方法学</h3><ul><li><p>通常把在软件生命周期全过程使用的一整套技术方法的集合称为方法学，也称为范型。</p></li><li><p>软件工程方法学包含3个要素：方法、工具和过程，方法是主导，工具是辅助</p><ul><li>过程：为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</li><li>方法：完成软件开发的各项任务的技术方法，回答“怎样做”的问题；</li><li>工具：为运用方法而提供的自动的或半自动的软件工程支撑环境</li></ul></li><li><p>软件工程的目标</p><ul><li>在给定成本、进度的前提下，开发出满足用户需求的高质量的、易于维护的软件产品。</li><li>软件工程是从技术和管理两方面研究如何更好地开发和维护计算机软件。</li><li>成本、进度和质量将是未来若干年中导致软件激烈竞争的主要因素。</li></ul></li><li><p>软件工程面临的问题</p><ul><li>软件费用仍然很高。</li><li>可靠性难以稳定地保证。</li><li>可维护性差。</li><li>可重用性低。</li><li>生产率不能有效提高。</li></ul></li><li><p>传统方法学（生命周期法或结构化范型）</p><ul><li>这种方法学把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。</li></ul></li><li><p>面向对象方法学</p><ul><li><p>面向对象方法是把数据和行为看成同等重要，是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。面向对象方法学有下述4个要点：</p><ul><li>（1）把对象作为融合了数据及在数据上的操作行为的统一的软件构建。</li><li>（2）把所有对象都划分成类</li><li>（3）按照父类（或称基类）与子类（或称为派生类）的关系，把若干个相关类组成一个层次结构的系统。</li><li>（4）对象彼此间仅能通过发送消息互相联系。</li></ul></li></ul></li></ul><h2 id="1-3软件生命周期"><a href="#1-3软件生命周期" class="headerlink" title="1.3软件生命周期"></a>1.3软件生命周期</h2><h3 id="软件定义"><a href="#软件定义" class="headerlink" title="软件定义"></a>软件定义</h3><ul><li><p>问题定义</p><ul><li>要解决的问题是什么？</li></ul></li><li><p>可行性研究</p><ul><li>对于上一个阶段所确定的问题有行得通的解决办法吗？</li></ul></li><li><p>需求分析</p><ul><li>为了解决这个问题，目标系统必须做什么？</li></ul></li></ul><h3 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h3><ul><li><p>总体设计</p><ul><li>概括地说，应该怎样实现目标系统？</li></ul></li><li><p>详细设计</p><ul><li>应该怎样具体实现这个系统呢？</li></ul></li><li><p>编码和单元测试</p><ul><li>写出正确的容易理解、容易维护的程序模块</li></ul></li><li><p>综合测试</p><ul><li>通过各种类型的测试（及相应的调试）使软件达到预定的要求。</li></ul></li></ul><h3 id="运行和维护"><a href="#运行和维护" class="headerlink" title="运行和维护"></a>运行和维护</h3><ul><li><p>软件维护</p><ul><li>通过各种必要的维护性活动使系统持久地满足用户的需求</li><li>改正性维护</li><li>适应性维护</li><li>完善性维护</li><li>预防性维护</li></ul></li></ul><h2 id="1-4软件过程"><a href="#1-4软件过程" class="headerlink" title="1.4软件过程"></a>1.4软件过程</h2><h3 id="1-4-1瀑布模型"><a href="#1-4-1瀑布模型" class="headerlink" title="1.4.1瀑布模型"></a>1.4.1瀑布模型</h3><ul><li>1.阶段间具有顺序性和依赖性</li><li>2.推迟实现的观点</li><li>3.质量保证的观点</li><li>优点：<ul><li>可强迫开发人员采用规范的方法；</li><li>严格地规定了每个阶段必须提交的文档；</li><li>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。</li><li>对文档的约束，使软件维护变得容易一些，且能降低软件预算</li></ul></li><li>缺点：<ul><li>开发过程一般不能逆转，否则代价太大；</li><li>实际的项目开发很难严格按该模型进行；</li><li>客户往往很难清楚地给出所有需求；</li><li>软件的实际情况必须到项目开发的后期客户才能看到</li></ul></li><li>适用范围：<ul><li>用户的需求非常清楚全面，且在开发过程中没有或很少变化</li><li>开发人员对软件的应用领域很熟悉</li><li>用户的使用环境非常稳定</li><li>开发工作对用户参与的需求很低</li></ul></li></ul><h3 id="1-4-2快速原型模型"><a href="#1-4-2快速原型模型" class="headerlink" title="1.4.2快速原型模型"></a>1.4.2快速原型模型</h3><ul><li>快速原型是快速建立起来的可以在计算机上运行的程序，它能完成的功能往往是最终产品能完成的功能的一个子集。</li><li>优点：<ul><li>可以得到比较好的需求分析定义，容易使用需求的变化；</li><li>有利于开发与培训同步；</li><li>开发费用低，开发周期短且对用户更友好。</li></ul></li><li>缺点：<ul><li>客户与开发者对原型理解不同；</li><li>准确的原型设计比较困难；</li><li>不利于开发人员的创新；</li></ul></li><li>适用范围：<ul><li>对所开发的领域比较熟悉而且有快速的原型开发工具；</li><li>项目招投标时，可以用原型模型作为软件的开发模型</li><li>进行产品移植或升级时，或对已有原型进行客户工作化时。</li></ul></li></ul><h3 id="1-4-3增量模型"><a href="#1-4-3增量模型" class="headerlink" title="1.4.3增量模型"></a>1.4.3增量模型</h3><ul><li>使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。</li><li>优点：<ul><li>能在短时间内向用户提交可完成部分工作的产品</li><li>逐步增加功能，减少了全新的软件可能给客户组织带来的冲击</li></ul></li><li>缺点：<ul><li>并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；</li><li>增量模型的灵活性很容易退化成边做边改模型，从而使软件过程的控制失去整体性。</li></ul></li><li>适用范围：<ul><li>进行已有产品升级或新版本开发；</li><li>对完成期限严格要求的产品</li><li>对所开发的领域比较熟悉而且已有原型系统。</li></ul></li></ul><h3 id="1-4-4螺旋模型"><a href="#1-4-4螺旋模型" class="headerlink" title="1.4.4螺旋模型"></a>1.4.4螺旋模型</h3><ul><li>基本思想是，使用原型及其他方法来尽量降低风险</li><li>优点：<ul><li>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量组为软件开发的一个重要目标；</li><li>减少了过多测试或测试不足所带来的分线；</li><li>在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别。</li></ul></li><li>缺点：<ul><li>需要丰富的风险评估经验和专门知识，如果未能够即使标识风险，会造成重大损失</li><li>过多的迭代次数会增加开发成本，延迟提交时间。</li></ul></li><li>适用范围：<ul><li>适用于内部开发的大规模软件项目</li></ul></li></ul><h3 id="1-4-5喷泉模型"><a href="#1-4-5喷泉模型" class="headerlink" title="1.4.5喷泉模型"></a>1.4.5喷泉模型</h3><ul><li>”喷泉“这个词体现了面向对象软件开发过程迭代和无缝的特性。</li><li>为避免使用喷泉模型开发软件时开发过程过分无序，应该把一个线性过程作为总目标</li></ul><h3 id="1-4-6Rational统一过程"><a href="#1-4-6Rational统一过程" class="headerlink" title="1.4.6Rational统一过程"></a>1.4.6Rational统一过程</h3><ul><li><p>最佳实践</p><ul><li>迭代式开发</li><li>管理需求</li><li>使用基于构件的体系结构</li><li>可视化建模（UML）</li><li>验证软件质量</li><li>控制软件变更</li></ul></li><li><p>RUP软件开发生命周期</p><ul><li><p>（1）核心工作流</p><ul><li>业务建模</li><li>需求</li><li>分析与设计</li><li>实现</li><li>测试</li><li>部署</li><li>配置与变更管理</li><li>项目管理</li><li>环境</li></ul></li><li><p>（2）工作阶段</p><ul><li>初始阶段</li><li>精化阶段</li><li>构建阶段</li><li>移交阶段</li></ul></li></ul></li></ul><h3 id="1-4-7敏捷过程与极限编程"><a href="#1-4-7敏捷过程与极限编程" class="headerlink" title="1.4.7敏捷过程与极限编程"></a>1.4.7敏捷过程与极限编程</h3><ul><li><p>敏捷过程</p><ul><li>个体和交互胜过过程和工具—合作、沟通交互更重要</li><li>可以工作的软件胜过面面俱到的文档</li><li>客户合作胜过合同谈判</li><li>相应变化胜过遵循计划</li></ul></li><li><p>极限编程。把好的开发实践运用到极致。极限编程广泛应用于需求模糊且经常改变的场合。</p><ul><li>客户作为开发团队成员</li><li>使用用户素材</li><li>短交付周期—反复迭代，每次完成部分需求</li><li>验收测试</li><li>结对编程—两人在用一台机器上共同编写同一程序，编码；审查测试</li><li>测试驱动开发—先设计测试方案，再编程，所有测试通过才能结束</li><li>集体所有—代码归属集体，每个成员都可以修改，都对全部代码质量负责</li><li>持续集成— 一天之内多次集成系统，根据需求变化，不断进行回归测试</li><li>可持续的开发速度</li><li>开放的工作空间—在同一场所一起工作，方便自由交流讨论</li><li>及时调整计划</li><li>简单的设计</li><li>代码重构—在不改变系统行为的前提下，重新调整和优化系统内部结构，以提高系统性能</li><li>使用隐喻—把隐喻看成是系统的全局视图，描述系统如何运作</li></ul></li></ul><h3 id="1-4-8微软过程"><a href="#1-4-8微软过程" class="headerlink" title="1.4.8微软过程"></a>1.4.8微软过程</h3><ul><li><p>基本准则</p><ul><li>项目计划应该兼顾未来的不确定因素</li><li>有用效的风险管理来减少不确定因素的影响</li><li>经常生成并快速地测试软件的过渡版本，以提高软件的稳定性和可预测性</li><li>采用快速循环、递进的开发过程</li><li>项目进度表应该具有较高稳定性和权威性</li><li>使用小型项目组并发地完成开发工作</li><li>使用原型验证概念，对项目进行早期论证</li><li>把零缺陷作为追求的目标</li><li>里程碑评审会的目的是改进工作，切记相互指责</li></ul></li><li><p>生命周期</p><ul><li>微软过程把软件生命周期分为5个阶段，即规划、设计、开发、稳定、发布。各阶段有里程碑。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 期中复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程多进程与协程</title>
      <link href="2020/08/28/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"/>
      <url>2020/08/28/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在介绍多线程之前，首先需要熟悉并发和并行，同步和异步的概念。如果阅读完本文章后仍对并发和并行、同步和异步的概念不太理解，没有关系，可以通过代码来慢慢了解这些概念的意义。</p></blockquote><h2 id="1-0基础概念解释"><a href="#1-0基础概念解释" class="headerlink" title="1.0基础概念解释"></a>1.0基础概念解释</h2><h3 id="1-1并发和并行"><a href="#1-1并发和并行" class="headerlink" title="1.1并发和并行"></a>1.1并发和并行</h3><p>  <strong>并发</strong>（concurrency）和<strong>并行</strong>（parallelism）是两个相似的概念。引用一个比较容易理解的说法，并发是指在一个时间段内发生若干时间的情况，并行是指在同一时刻发生若干事件的情况。</p><p>  这个概念用单核CPU和多核CPU比较容易说明。在使用单核CPU是，多个工作任务是以并发的方式运行的，因为只有一个CPU，所以各个任务会分别占用CPU的一段时间依次执行。如果在自己分得的时间段没有完成任务，就会切换到另一个任务，然后在下一次得到CPU使用权的时候再继续执行，以此类推，直到完成任务。在这种情况下，因为各个任务的时间段很短、经常切换，所以给我们的感觉是“同时”进行。在使用多核CPU时，在各个核的任务能够同时运行，也就是并行。</p><h3 id="1-2同步和异步"><a href="#1-2同步和异步" class="headerlink" title="1.2同步和异步"></a>1.2同步和异步</h3><p>  同步和异步也是两个值得比较的概念。下面在并发和并行框架的基础上理解同步和异步，同步就是并发或并行的各个任务不是独自运行的，任务之间有一定的交替顺序，可能在运行完成一个任务得到结果后，另一个任务才会开始运行。就像接力赛跑一样、要拿到交接棒之后下一个选手才可以开始跑。</p><p>  异步则是并发或并行的各个任务可以独立运行，一个任务的运行不受另一个任务影响，任务之间就像比赛的各个选手在不同的赛道比赛一样，跑步的速度不受其他赛道选手的影响。</p><h2 id="2-0多线程"><a href="#2-0多线程" class="headerlink" title="2.0多线程"></a>2.0多线程</h2><p><strong>_thread模块</strong><a href="https://docs.python.org/zh-cn/3/library/_thread.html#module-_thread">官方文档说明</a></p><p><strong>threading</strong><a href="https://docs.python.org/zh-cn/3/library/threading.html">官方文档说明</a></p><p>如果要使用多线程，那么需要先了解Python中使用多线程的两种方法。</p><ul><li>函数式：调用<strong>_thread</strong>模块中的**start_new_thread()**函数产生新线程。</li><li>类包装式：调用<strong>Threading</strong>库创建线程，从<strong>threading.Thread</strong>继承。</li></ul><h3 id="2-1-thread模块"><a href="#2-1-thread模块" class="headerlink" title="2.1_thread模块"></a>2.1_thread模块</h3><p>首先介绍函数式，在Python3中不能继续使用thread模块。为了兼容性考虑，Python3将<strong>thread</strong>重命名为<strong>_thread</strong>。</p><p>下面用实例感受一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#为线程定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay</span>):</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    time.sleep(delay)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    print(threadName,time.ctime(time.time()))</span><br><span class="line"><span class="comment">#创建两个线程</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  _thread.start_new(print_time, (<span class="string">&#x27;Thread-1&#x27;</span>,<span class="number">1</span>))</span><br><span class="line">  _thread.start_new(print_time, (<span class="string">&#x27;Thread-2&#x27;</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  print(<span class="string">&#x27;Error:无法启动线程&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果主线程结束的话，其他线程也会随之结束</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  print(<span class="string">&#x27;Main Finished&#x27;</span>)</span><br><span class="line">  time.sleep(<span class="number">15</span>)</span><br><span class="line">  <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>运行上述代码得到的结果是：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Main Finished </span><br><span class="line"></span><br><span class="line">Thread-1 Thu Aug 20 03:15:31 2020 </span><br><span class="line"></span><br><span class="line">Thread-1 Thu Aug 20 03:15:32 2020 </span><br><span class="line"></span><br><span class="line">Thread-2 Thu Aug 20 03:15:32 2020 </span><br><span class="line"></span><br><span class="line">Thread-1 Thu Aug 20 03:15:33 2020 </span><br><span class="line"></span><br><span class="line">Thread-2 Thu Aug 20 03:15:34 2020 </span><br><span class="line"></span><br><span class="line">Thread-2 Thu Aug 20 03:15:36 2020</span><br></pre></td></tr></table></figure><p><strong>_thread</strong>中使用**start_new_thread()**函数来产生新线程，语法如下：</p><blockquote><p><strong>_thread.start_new_thread(<em>function</em>, <em>args</em>[, <em>kwargs</em>])</strong></p></blockquote><p>其中，function表示线程函数，在上例中为<em>print_time</em>；<em>args</em>为传递给线程函数的参数，它必须是<em>tuple</em>类型，在上例中为*(‘Thread-1’, 1)*；可选的 <em>kwargs</em> 参数指定一个关键字参数字典。</p><h3 id="2-2threading模块"><a href="#2-2threading模块" class="headerlink" title="2.2threading模块"></a>2.2threading模块</h3><p>_thread提供了低级别、原始的线程，它相比于threading模块，功能还是比较有限的。threading模块提供了<em>Thread</em>类来处理线程，threading 模块除了包含 _thread 模块中的所有方法外，包括以下方法。</p><ul><li>threading.currentThread(): 返回当前的线程变量。</li><li>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</li><li>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</li></ul><p>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</p><ul><li><p><strong>run():</strong> 用以表示线程活动的方法。</p></li><li><p>**start():**启动线程活动。</p></li><li><p><strong>join([time]):</strong> 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</p></li><li><p><strong>isAlive():</strong> 返回线程是否活动的。</p></li><li><p><strong>getName():</strong> 返回线程名。</p></li><li><p><strong>setName():</strong> 设置线程名。</p></li><li><p><strong>setDaemon(bool)</strong></p><p>一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 <code>start()</code>前设置好，不然会抛出 <code>RuntimeError</code> 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 <code>daemon</code> = <code>False</code>。当没有存活的非守护线程时，整个Python程序才会退出。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, counter</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开始线程：&quot;</span> + self.name)</span><br><span class="line">        print_time(self.name, self.counter, <span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;退出线程：&quot;</span> + self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay, counter</span>):</span></span><br><span class="line">    <span class="keyword">while</span> counter:</span><br><span class="line">        <span class="keyword">if</span> exitFlag:</span><br><span class="line">            threadName.exit()</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line">thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">开始线程：Thread-1 </span><br><span class="line"></span><br><span class="line">开始线程：Thread-2 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:24 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:25 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:25 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:26 2020</span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:27 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:27 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 03:55:28 2020 </span><br><span class="line"></span><br><span class="line">退出线程：Thread-1 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:29 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:31 2020</span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 03:55:33 2020 </span><br><span class="line"></span><br><span class="line">退出线程：Thread-2 </span><br><span class="line"></span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><h3 id="2-3线程同步"><a href="#2-3线程同步" class="headerlink" title="2.3线程同步"></a>2.3线程同步</h3><h4 id="2-3-1线程同步说明"><a href="#2-3-1线程同步说明" class="headerlink" title="2.3.1线程同步说明"></a>2.3.1线程同步说明</h4><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</p><p>使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：</p><p>多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。</p><p>考虑这样一种情况：一个列表里所有元素都是0，线程”set”从后向前把所有元素改成1，而线程”print”负责从前往后读取列表并打印。</p><p>那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。</p><p>锁有两种状态——锁定和未锁定。每当一个线程比如”set”要访问共享数据时，必须先获得锁定；如果已经有别的线程比如”print”获得锁定了，那么就让线程”set”暂停，也就是同步阻塞；等到线程”print”访问完毕，释放锁以后，再让线程”set”继续。</p><p>经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。</p><h4 id="2-3-2示例代码"><a href="#2-3-2示例代码" class="headerlink" title="2.3.2示例代码"></a>2.3.2示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, counter</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程： &quot;</span> + self.name)</span><br><span class="line">        <span class="comment"># 获取锁，用于线程同步</span></span><br><span class="line">        threadLock.acquire()</span><br><span class="line">        print_time(self.name, self.counter, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line">        threadLock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay, counter</span>):</span></span><br><span class="line">    <span class="keyword">while</span> counter:</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threadLock = threading.Lock()</span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line">thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加线程到线程列表</span></span><br><span class="line">threads.append(thread1)</span><br><span class="line">threads.append(thread2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">开启线程： Thread-1 </span><br><span class="line"></span><br><span class="line">开启线程： Thread-2 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 04:06:06 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 04:06:07 2020 </span><br><span class="line"></span><br><span class="line">Thread-1: Thu Aug 20 04:06:08 2020</span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 04:06:10 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 04:06:12 2020 </span><br><span class="line"></span><br><span class="line">Thread-2: Thu Aug 20 04:06:14 2020 </span><br><span class="line"></span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><h3 id="2-4线程优先级队列（Queue）"><a href="#2-4线程优先级队列（Queue）" class="headerlink" title="2.4线程优先级队列（Queue）"></a>2.4线程优先级队列（Queue）</h3><h4 id="2-4-1Queue模块基本说明"><a href="#2-4-1Queue模块基本说明" class="headerlink" title="2.4.1Queue模块基本说明"></a>2.4.1Queue模块基本说明</h4><p>Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。</p><p>这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p><p>Queue 模块中的常用方法:</p><ul><li><code>Queue.qsize</code>() 返回队列的大小</li><li><code>Queue.empty</code>() 如果队列为空，返回True,反之False</li><li><code>Queue.full</code>() 如果队列满了，返回True,反之False</li><li><code>Queue.full</code> 与 <code>maxsize</code> 大小对应</li><li><code>Queue.get</code>([block[, timeout]])获取队列，timeout等待时间</li><li><code>Queue.get_nowait(</code>) 相当<code>Queue.get</code>(False)</li><li><code>Queue.put</code>(item) 写入队列，timeout等待时间</li><li><code>Queue.put_nowait</code>(item) 相当<code>Queue.put</code>(item, False)</li><li><code>Queue.task_done</code>() 在完成一项工作之后，<code>Queue.task_done</code>()函数向任务已经完成的队列发送一个信号</li><li><code>Queue.join</code>() 实际上意味着等到队列为空，再执行别的操作</li></ul><h4 id="2-4-1示例代码"><a href="#2-4-1示例代码" class="headerlink" title="2.4.1示例代码"></a>2.4.1示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, q</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.q = q</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程：&quot;</span> + self.name)</span><br><span class="line">        process_data(self.name, self.q)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;退出线程：&quot;</span> + self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_data</span>(<span class="params">threadName, q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exitFlag:</span><br><span class="line">        queueLock.acquire()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> workQueue.empty():</span><br><span class="line">            data = q.get()</span><br><span class="line">            queueLock.release()</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;%s processing %s&quot;</span> % (threadName, data))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queueLock.release()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">threadList = [<span class="string">&quot;Thread-1&quot;</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="string">&quot;Thread-3&quot;</span>]</span><br><span class="line">nameList = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>]</span><br><span class="line">queueLock = threading.Lock()</span><br><span class="line">workQueue = queue.Queue(<span class="number">10</span>)</span><br><span class="line">threads = []</span><br><span class="line">threadID = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line"><span class="keyword">for</span> tName <span class="keyword">in</span> threadList:</span><br><span class="line">    thread = myThread(threadID, tName, workQueue)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    threadID += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充队列</span></span><br><span class="line">queueLock.acquire()</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> nameList:</span><br><span class="line">    workQueue.put(word)</span><br><span class="line">queueLock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待队列清空</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> workQueue.empty():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知线程是时候退出</span></span><br><span class="line">exitFlag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><p>由于Queue是线程安全的队列，故不用<code>Lock</code>对象来进行线程同步也可以，下面代码和上述代码得到的结果一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, q</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.q = q</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程：&quot;</span> + self.name)</span><br><span class="line">        process_data(self.name, self.q)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;退出线程：&quot;</span> + self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_data</span>(<span class="params">threadName, q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exitFlag:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> workQueue.empty():</span><br><span class="line">            data = q.get()</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;%s processing %s&quot;</span> % (threadName, data))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">threadList = [<span class="string">&quot;Thread-1&quot;</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="string">&quot;Thread-3&quot;</span>]</span><br><span class="line">nameList = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>]</span><br><span class="line">workQueue = queue.Queue(<span class="number">10</span>)</span><br><span class="line">threads = []</span><br><span class="line">threadID = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line"><span class="keyword">for</span> tName <span class="keyword">in</span> threadList:</span><br><span class="line">    thread = myThread(threadID, tName, workQueue)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    threadID += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充队列</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> nameList:</span><br><span class="line">    workQueue.put(word)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待队列清空</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> workQueue.empty():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知线程是时候退出</span></span><br><span class="line">exitFlag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行上述代码得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">开启线程：Thread-1</span><br><span class="line">开启线程：Thread-2</span><br><span class="line">开启线程：Thread-3</span><br><span class="line">Thread-2 processing One</span><br><span class="line">Thread-3 processing Two</span><br><span class="line">Thread-1 processing Three</span><br><span class="line">Thread-2 processing Four</span><br><span class="line">Thread-3 processing Five</span><br><span class="line">退出线程：Thread-1</span><br><span class="line">退出线程：Thread-2</span><br><span class="line">退出线程：Thread-3</span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><h2 id="3-0多进程"><a href="#3-0多进程" class="headerlink" title="3.0多进程"></a>3.0多进程</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
